<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Never's Blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://xfhnever.com/"/>
  <updated>2015-12-12T08:09:11.000Z</updated>
  <id>http://xfhnever.com/</id>
  
  <author>
    <name><![CDATA[Never]]></name>
    <email><![CDATA[xfhnever@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Java(十四)-CPU飙升问题排查]]></title>
    <link href="http://xfhnever.com/2015/10/29/java-hashmap-cpu100/"/>
    <id>http://xfhnever.com/2015/10/29/java-hashmap-cpu100/</id>
    <published>2015-10-29T14:26:25.000Z</published>
    <updated>2015-12-12T08:09:11.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题">问题</h2><p>最近部署的应用监控提示一台机器CPU的load特别高，而部署相同应用的其他机器却没有任何问题。本文就记录下来解决该问题的整个过程。</p>
<a id="more"></a>
<h2 id="排查问题">排查问题</h2><p>首先是上线之后top命令，发现CPU飙高的正是部署在机器上的Java进程。</p>
<ol>
<li><p>jstack打印Java堆栈信息，保留现场</p>
<pre><code>jstack pid &gt; jstack.<span class="command">log</span>
</code></pre></li>
<li>查看堆栈信息，同事提醒说，一般CPU飙高主要查看堆栈Runnale的线程。但是漫无目标去查看，很难定位到问题。</li>
<li>通过 top -H -p PID命令输出占用cpu过高的线程</li>
<li><p>将占用CPU过高的线程ID转换为16进制</p>
<pre><code><span class="keyword">printf</span> <span class="variable">%x</span> pid
</code></pre></li>
<li>去原来保存的堆栈文件中查找对应线程，就是出问题的线程。最终我们发现问题线程如下：</li>
</ol>
<pre><code><span class="string">"HSFBizProcessor-8-thread-2300"</span> daemon prio=<span class="number">10</span> tid=<span class="number">0</span>x00007fbb4813e000 nid=<span class="number">0</span>x5c94 runnable [<span class="number">0</span>x00007fbb3a8b0000]
   java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.State</span>: RUNNABLE
    at java<span class="class">.util</span><span class="class">.HashMap</span><span class="class">.getEntry</span>(HashMap<span class="class">.java</span>:<span class="number">469</span>)
    at java<span class="class">.util</span><span class="class">.HashMap</span><span class="class">.containsKey</span>(HashMap<span class="class">.java</span>:<span class="number">453</span>)
    at java<span class="class">.util</span><span class="class">.HashSet</span><span class="class">.contains</span>(HashSet<span class="class">.java</span>:<span class="number">201</span>)
    at com<span class="class">.ttpod</span><span class="class">.alimusic</span><span class="class">.BaseClient</span><span class="class">.saveLoseDataLog</span>(BaseClient<span class="class">.java</span>:<span class="number">201</span>)
    at com<span class="class">.ttpod</span><span class="class">.alimusic</span><span class="class">.client</span><span class="class">.SongClient</span><span class="class">.getAudioForSongs</span>(SongClient<span class="class">.java</span>:<span class="number">103</span>)
    at com<span class="class">.ttpod</span><span class="class">.alimusic</span><span class="class">.client</span><span class="class">.SongClient</span>$<span class="variable">$FastClassBySpringCGLIB</span>$$<span class="number">4</span>c35f712.<span class="function"><span class="title">invoke</span><span class="params">(&lt;generated&gt;)</span></span>
    at org<span class="class">.springframework</span><span class="class">.cglib</span><span class="class">.proxy</span><span class="class">.MethodProxy</span><span class="class">.invoke</span>(MethodProxy<span class="class">.java</span>:<span class="number">204</span>)
    at org<span class="class">.springframework</span><span class="class">.aop</span><span class="class">.framework</span><span class="class">.CglibAopProxy</span><span class="variable">$CglibMethodInvocation</span>.<span class="function"><span class="title">invokeJoinpoint</span><span class="params">(CglibAopProxy.java:<span class="number">708</span>)</span></span>
    at org<span class="class">.springframework</span><span class="class">.aop</span><span class="class">.framework</span><span class="class">.ReflectiveMethodInvocation</span><span class="class">.proceed</span>(ReflectiveMethodInvocation<span class="class">.java</span>:<span class="number">157</span>)
    at org<span class="class">.springframework</span><span class="class">.aop</span><span class="class">.aspectj</span><span class="class">.MethodInvocationProceedingJoinPoint</span><span class="class">.proceed</span>(MethodInvocationProceedingJoinPoint<span class="class">.java</span>:<span class="number">85</span>)
    at com<span class="class">.ttpod</span><span class="class">.alimusic</span><span class="class">.aspect</span><span class="class">.LogAspect</span><span class="class">.doLog</span>(LogAspect<span class="class">.java</span>:<span class="number">49</span>)
    at sun<span class="class">.reflect</span><span class="class">.GeneratedMethodAccessor20</span><span class="class">.invoke</span>(Unknown Source)
    at sun<span class="class">.reflect</span><span class="class">.DelegatingMethodAccessorImpl</span><span class="class">.invoke</span>(DelegatingMethodAccessorImpl<span class="class">.java</span>:<span class="number">43</span>)
    at java<span class="class">.lang</span><span class="class">.reflect</span><span class="class">.Method</span><span class="class">.invoke</span>(Method<span class="class">.java</span>:<span class="number">606</span>)
    at org<span class="class">.springframework</span><span class="class">.aop</span><span class="class">.aspectj</span><span class="class">.AbstractAspectJAdvice</span><span class="class">.invokeAdviceMethodWithGivenArgs</span>(AbstractAspectJAdvice<span class="class">.java</span>:<span class="number">621</span>)
    at org<span class="class">.springframework</span><span class="class">.aop</span><span class="class">.aspectj</span><span class="class">.AbstractAspectJAdvice</span><span class="class">.invokeAdviceMethod</span>(AbstractAspectJAdvice<span class="class">.java</span>:<span class="number">610</span>)
    at org<span class="class">.springframework</span><span class="class">.aop</span><span class="class">.aspectj</span><span class="class">.AspectJAroundAdvice</span><span class="class">.invoke</span>(AspectJAroundAdvice<span class="class">.java</span>:<span class="number">68</span>)
    at org<span class="class">.springframework</span><span class="class">.aop</span><span class="class">.framework</span><span class="class">.ReflectiveMethodInvocation</span><span class="class">.proceed</span>(ReflectiveMethodInvocation<span class="class">.java</span>:<span class="number">179</span>)
    at org<span class="class">.springframework</span><span class="class">.aop</span><span class="class">.interceptor</span><span class="class">.ExposeInvocationInterceptor</span><span class="class">.invoke</span>(ExposeInvocationInterceptor<span class="class">.java</span>:<span class="number">92</span>)
    at org<span class="class">.springframework</span><span class="class">.aop</span><span class="class">.framework</span><span class="class">.ReflectiveMethodInvocation</span><span class="class">.proceed</span>(ReflectiveMethodInvocation<span class="class">.java</span>:<span class="number">179</span>)
    at org<span class="class">.springframework</span><span class="class">.aop</span><span class="class">.framework</span><span class="class">.CglibAopProxy</span><span class="variable">$DynamicAdvisedInterceptor</span>.<span class="function"><span class="title">intercept</span><span class="params">(CglibAopProxy.java:<span class="number">644</span>)</span></span>
    at com<span class="class">.ttpod</span><span class="class">.alimusic</span><span class="class">.client</span><span class="class">.SongClient</span>$<span class="variable">$EnhancerBySpringCGLIB</span>$$<span class="number">931</span>c77b8.<span class="function"><span class="title">getAudioForSongs</span><span class="params">(&lt;generated&gt;)</span></span>
    at com<span class="class">.ttpod</span><span class="class">.alimusic</span><span class="class">.dao</span><span class="class">.SongFileALiDao</span><span class="class">.getSongFiles</span>(SongFileALiDao<span class="class">.java</span>:<span class="number">31</span>)
    at com<span class="class">.ttpod</span><span class="class">.cache</span><span class="class">.SongFileListCache</span><span class="class">.lazyLoad</span>(SongFileListCache<span class="class">.java</span>:<span class="number">38</span>)
    at com<span class="class">.ttpod</span><span class="class">.cache</span><span class="class">.LocalListCache</span><span class="class">.getList</span>(LocalListCache<span class="class">.java</span>:<span class="number">57</span>)
    at com<span class="class">.ttpod</span><span class="class">.song</span><span class="class">.service</span><span class="class">.SongFileServiceImpl</span><span class="class">.getSongFilesByIds</span>(SongFileServiceImpl<span class="class">.java</span>:<span class="number">86</span>)
    at com<span class="class">.ttpod</span><span class="class">.song</span><span class="class">.service</span><span class="class">.SongServiceImpl</span><span class="class">.fillUrl</span>(SongServiceImpl<span class="class">.java</span>:<span class="number">424</span>)
    at com<span class="class">.ttpod</span><span class="class">.song</span><span class="class">.service</span><span class="class">.SongServiceImpl</span><span class="class">.loadSongFiles</span>(SongServiceImpl<span class="class">.java</span>:<span class="number">117</span>)
    at sun<span class="class">.reflect</span><span class="class">.GeneratedMethodAccessor439</span><span class="class">.invoke</span>(Unknown Source)
    at sun<span class="class">.reflect</span><span class="class">.DelegatingMethodAccessorImpl</span><span class="class">.invoke</span>(DelegatingMethodAccessorImpl<span class="class">.java</span>:<span class="number">43</span>)
    at java<span class="class">.lang</span><span class="class">.reflect</span><span class="class">.Method</span><span class="class">.invoke</span>(Method<span class="class">.java</span>:<span class="number">606</span>)
    at com<span class="class">.taobao</span><span class="class">.hsf</span><span class="class">.remoting</span><span class="class">.provider</span><span class="class">.ProviderProcessor</span><span class="class">.handleRequest0</span>(ProviderProcessor<span class="class">.java</span>:<span class="number">471</span>)
    at com<span class="class">.taobao</span><span class="class">.hsf</span><span class="class">.remoting</span><span class="class">.provider</span><span class="class">.ProviderProcessor</span><span class="class">.handleRequest</span>(ProviderProcessor<span class="class">.java</span>:<span class="number">152</span>)
    at com<span class="class">.taobao</span><span class="class">.hsf</span><span class="class">.remoting</span><span class="class">.server</span><span class="class">.RPCServerHandler</span><span class="class">.handleRequest</span>(RPCServerHandler<span class="class">.java</span>:<span class="number">43</span>)
    at com<span class="class">.taobao</span><span class="class">.hsf</span><span class="class">.remoting</span><span class="class">.server</span><span class="class">.RPCServerHandler</span><span class="class">.handleRequest</span>(RPCServerHandler<span class="class">.java</span>:<span class="number">21</span>)
    at com<span class="class">.taobao</span><span class="class">.hsf</span><span class="class">.remoting</span><span class="class">.netty</span><span class="class">.server</span><span class="class">.NettyServerHandler</span><span class="variable">$HandlerRunnable</span>.<span class="function"><span class="title">run</span><span class="params">(NettyServerHandler.java:<span class="number">109</span>)</span></span>
    at java<span class="class">.util</span><span class="class">.concurrent</span><span class="class">.ThreadPoolExecutor</span><span class="class">.runWorker</span>(ThreadPoolExecutor<span class="class">.java</span>:<span class="number">1145</span>)
    at java<span class="class">.util</span><span class="class">.concurrent</span><span class="class">.ThreadPoolExecutor</span><span class="variable">$Worker</span>.<span class="function"><span class="title">run</span><span class="params">(ThreadPoolExecutor.java:<span class="number">615</span>)</span></span>
    at java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.run</span>(Thread<span class="class">.java</span>:<span class="number">744</span>)
</code></pre><p>后面看到一个更好的排查方案：<a href="https://github.com/oldratlee/useful-scripts/blob/master/show-busy-java-threads.sh" target="_blank" rel="external">show-busy-java-threads.sh</a></p>
<h2 id="解决方案">解决方案</h2><p>将HashMap换成线程安全的ConcurrentHashMap.</p>
<p>至于关于HashMap线程不安全问题，可以查看左耳朵耗子的分析 <a href="http://coolshell.cn/articles/9606.html" target="_blank" rel="external">疫苗：Java HashMap的死循环</a></p>
<h2 id="参考">参考</h2><ol>
<li><a href="http://blog.csdn.net/fenglibing/article/details/6411940" target="_blank" rel="external">jstack命令(Java Stack Trace)</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="问题">问题</h2><p>最近部署的应用监控提示一台机器CPU的load特别高，而部署相同应用的其他机器却没有任何问题。本文就记录下来解决该问题的整个过程。</p>]]>
    
    </summary>
    
      <category term="Java" scheme="http://xfhnever.com/tags/Java/"/>
    
      <category term="Java" scheme="http://xfhnever.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mongodb(十二)- 慢查询]]></title>
    <link href="http://xfhnever.com/2015/10/28/mongodb-slow-query/"/>
    <id>http://xfhnever.com/2015/10/28/mongodb-slow-query/</id>
    <published>2015-10-28T14:01:15.000Z</published>
    <updated>2016-01-17T03:28:10.000Z</updated>
    <content type="html"><![CDATA[<p>最近公司曲库接入新曲库上线，昨晚高峰期的时候应用报警，上去发现很多MongoTimeoutException异常，该异常最近一直有遇到，原因更是如出一辙，所以这里就记录一下。</p>
<a id="more"></a>
<h2 id="异常日志">异常日志</h2><pre><code>com<span class="class">.mongodb</span><span class="class">.MongoTimeoutException</span>: Timeout waiting <span class="keyword">for</span> <span class="tag">a</span> pooled item after <span class="number">3000</span> MILLISECONDS
    at com<span class="class">.mongodb</span><span class="class">.ConcurrentPool</span><span class="class">.get</span>(ConcurrentPool<span class="class">.java</span>:<span class="number">113</span>)
    at com<span class="class">.mongodb</span><span class="class">.PooledConnectionProvider</span><span class="class">.get</span>(PooledConnectionProvider<span class="class">.java</span>:<span class="number">75</span>)
    at com<span class="class">.mongodb</span><span class="class">.DefaultServer</span><span class="class">.getConnection</span>(DefaultServer<span class="class">.java</span>:<span class="number">60</span>)
    at com<span class="class">.mongodb</span><span class="class">.BaseCluster</span><span class="variable">$WrappedServer</span>.<span class="function"><span class="title">getConnection</span><span class="params">(BaseCluster.java:<span class="number">216</span>)</span></span>
    at com<span class="class">.mongodb</span><span class="class">.DBTCPConnector</span><span class="variable">$MyPort</span>.<span class="function"><span class="title">getConnection</span><span class="params">(DBTCPConnector.java:<span class="number">503</span>)</span></span>
    at com<span class="class">.mongodb</span><span class="class">.DBTCPConnector</span><span class="variable">$MyPort</span>.<span class="function"><span class="title">get</span><span class="params">(DBTCPConnector.java:<span class="number">451</span>)</span></span>
    at com<span class="class">.mongodb</span><span class="class">.DBTCPConnector</span><span class="class">.innerCall</span>(DBTCPConnector<span class="class">.java</span>:<span class="number">286</span>)
    at com<span class="class">.mongodb</span><span class="class">.DBTCPConnector</span><span class="class">.call</span>(DBTCPConnector<span class="class">.java</span>:<span class="number">271</span>)
    at com<span class="class">.mongodb</span><span class="class">.DBCollectionImpl</span><span class="class">.find</span>(DBCollectionImpl<span class="class">.java</span>:<span class="number">84</span>)
    at com<span class="class">.mongodb</span><span class="class">.DBCollectionImpl</span><span class="class">.find</span>(DBCollectionImpl<span class="class">.java</span>:<span class="number">66</span>)
    at com<span class="class">.mongodb</span><span class="class">.DBCursor</span>._check(DBCursor<span class="class">.java</span>:<span class="number">458</span>)
    at com<span class="class">.mongodb</span><span class="class">.DBCursor</span>._hasNext(DBCursor<span class="class">.java</span>:<span class="number">546</span>)
    at com<span class="class">.mongodb</span><span class="class">.DBCursor</span><span class="class">.hasNext</span>(DBCursor<span class="class">.java</span>:<span class="number">571</span>)
    at org<span class="class">.jongo</span><span class="class">.MongoCursor</span><span class="class">.hasNext</span>(MongoCursor<span class="class">.java</span>:<span class="number">38</span>)
    at com<span class="class">.ttpod</span><span class="class">.common</span><span class="class">.mongo</span><span class="class">.CursorListHelper</span><span class="class">.convert</span>(CursorListHelper<span class="class">.java</span>:<span class="number">14</span>)
</code></pre><p>MongoDB默认的连接超时时间是3s，这里并不能通过简单设置超时时间来解决该问题，而是应该去数据库查看数据库的状态，最后发现是库中存在很多慢查询，一直占用连接不释放，导致其他连接超时。</p>
<h2 id="MongoDB的慢查询">MongoDB的慢查询</h2><p>慢查询是数据库查询优化的一部分内容，通过查看慢查询日志，可以找到数据库查询问题在哪里。</p>
<h3 id="开启Profiling功能">开启Profiling功能</h3><ol>
<li><p>客户端</p>
<pre><code>db.setProfilingLevel(<span class="number">1</span>);  
</code></pre><p> Level共有三个等级：</p>
<pre><code><span class="number">0</span> – 不开启
<span class="number">1</span> – 记录慢命令 (默认为&gt;<span class="number">100</span>ms)
<span class="number">2</span> – 记录所有命令
</code></pre><p> Level 1 的超时时间默认为100ms，可以通过</p>
<pre><code>db.<span class="function"><span class="title">setProfilingLevel</span><span class="params">( level , slowms )</span></span> 设置
</code></pre></li>
<li><p>启动时</p>
<pre><code>启动MongoDB时加上–<span class="keyword">profile</span> 和 –slowms 参数
        　　　
</code></pre></li>
</ol>
<h3 id="查询Profiling等级">查询Profiling等级</h3><pre><code><span class="tag">db</span><span class="class">.setProfilingLevel</span>();              　　　
</code></pre><h3 id="查询Profiling记录">查询Profiling记录</h3><p>Mongo Profile 记录是直接存在系统db里的，记录位置 system.profile ，所以，我们只要查询这个Collection的记录就可以获取到我们的 Profile 记录了</p>
<pre><code>ttrs_quku:SECONDARY&gt; db.system.profile.find()

{ <span class="string">"op"</span> : <span class="string">"getmore"</span>, <span class="string">"ns"</span> : <span class="string">"ttpod_songs.songsFile"</span>, <span class="string">"cursorid"</span> : <span class="number">653122545872</span>, <span class="string">"ntoreturn"</span> : <span class="number">0</span>, <span class="string">"keyUpdates"</span> : <span class="number">0</span>, <span class="string">"numYield"</span> : <span class="number">214</span>, <span class="string">"lockStats"</span> : { <span class="string">"timeLockedMicros"</span> : { <span class="string">"r"</span> : NumberLong(<span class="number">152153</span>), <span class="string">"w"</span> : NumberLong(<span class="number">0</span>) }, <span class="string">"timeAcquiringMicros"</span> : { <span class="string">"r"</span> : NumberLong(<span class="number">328</span>), <span class="string">"w"</span> : NumberLong(<span class="number">3</span>) } }, <span class="string">"nreturned"</span> : <span class="number">22676</span>, <span class="string">"responseLength"</span> : <span class="number">4194310</span>, <span class="string">"millis"</span> : <span class="number">132</span>, <span class="string">"execStats"</span> : {  }, <span class="string">"ts"</span> : ISODate(<span class="string">"2015-10-25T16:23:36.189Z"</span>), <span class="string">"client"</span> : <span class="string">"10.147.238.83"</span>, <span class="string">"allUsers"</span> : [ ], <span class="string">"user"</span> : <span class="string">""</span> }
{ <span class="string">"op"</span> : <span class="string">"getmore"</span>, <span class="string">"ns"</span> : <span class="string">"ttpod_songs.songsFile"</span>, <span class="string">"cursorid"</span> : <span class="number">653122545872</span>, <span class="string">"ntoreturn"</span> : <span class="number">0</span>, <span class="string">"keyUpdates"</span> : <span class="number">0</span>, <span class="string">"numYield"</span> : <span class="number">156</span>, <span class="string">"lockStats"</span> : { <span class="string">"timeLockedMicros"</span> : { <span class="string">"r"</span> : NumberLong(<span class="number">139827</span>), <span class="string">"w"</span> : NumberLong(<span class="number">0</span>) }, <span class="string">"timeAcquiringMicros"</span> : { <span class="string">"r"</span> : NumberLong(<span class="number">231</span>), <span class="string">"w"</span> : NumberLong(<span class="number">2</span>) } }, <span class="string">"nreturned"</span> : <span class="number">23193</span>, <span class="string">"responseLength"</span> : <span class="number">4194446</span>, <span class="string">"millis"</span> : <span class="number">107</span>, <span class="string">"execStats"</span> : {  }, <span class="string">"ts"</span> : ISODate(<span class="string">"2015-10-25T16:23:37.058Z"</span>), <span class="string">"client"</span> : <span class="string">"10.147.238.83"</span>, <span class="string">"allUsers"</span> : [ ], <span class="string">"user"</span> : <span class="string">""</span> }
{ <span class="string">"op"</span> : <span class="string">"getmore"</span>, <span class="string">"ns"</span> : <span class="string">"ttpod_songs.songsFile"</span>, <span class="string">"cursorid"</span> : <span class="number">653122545872</span>, <span class="string">"ntoreturn"</span> : <span class="number">0</span>, <span class="string">"keyUpdates"</span> : <span class="number">0</span>, <span class="string">"numYield"</span> : <span class="number">232</span>, <span class="string">"lockStats"</span> : { <span class="string">"timeLockedMicros"</span> : { <span class="string">"r"</span> : NumberLong(<span class="number">146159</span>), <span class="string">"w"</span> : NumberLong(<span class="number">0</span>) }, <span class="string">"timeAcquiringMicros"</span> : { <span class="string">"r"</span> : NumberLong(<span class="number">333</span>), <span class="string">"w"</span> : NumberLong(<span class="number">4</span>) } }, <span class="string">"nreturned"</span> : <span class="number">22450</span>, <span class="string">"responseLength"</span> : <span class="number">4194397</span>, <span class="string">"millis"</span> : <span class="number">120</span>, <span class="string">"execStats"</span> : {  }, <span class="string">"ts"</span> : ISODate(<span class="string">"2015-10-25T16:23:38.820Z"</span>), <span class="string">"client"</span> : <span class="string">"10.147.238.83"</span>, <span class="string">"allUsers"</span> : [ ], <span class="string">"user"</span> : <span class="string">""</span> }
{ <span class="string">"op"</span> : <span class="string">"getmore"</span>, <span class="string">"ns"</span> : <span class="string">"ttpod_songs.songsFile"</span>, <span class="string">"cursorid"</span> : <span class="number">653122545872</span>, <span class="string">"ntoreturn"</span> : <span class="number">0</span>, <span class="string">"keyUpdates"</span> : <span class="number">0</span>, <span class="string">"numYield"</span> : <span class="number">162</span>, <span class="string">"lockStats"</span> : { <span class="string">"timeLockedMicros"</span> : { <span class="string">"r"</span> : NumberLong(<span class="number">135602</span>), <span class="string">"w"</span> : NumberLong(<span class="number">0</span>) }, <span class="string">"timeAcquiringMicros"</span> : { <span class="string">"r"</span> : NumberLong(<span class="number">253</span>), <span class="string">"w"</span> : NumberLong(<span class="number">4</span>) } }, <span class="string">"nreturned"</span> : <span class="number">23162</span>, <span class="string">"responseLength"</span> : <span class="number">4194302</span>, <span class="string">"millis"</span> : <span class="number">101</span>, <span class="string">"execStats"</span> : {  }, <span class="string">"ts"</span> : ISODate(<span class="string">"2015-10-25T16:23:39.680Z"</span>), <span class="string">"client"</span> : <span class="string">"10.147.238.83"</span>, <span class="string">"allUsers"</span> : [ ], <span class="string">"user"</span> : <span class="string">""</span> }
</code></pre><p>其中：</p>
<ol>
<li>ts-该命令在何时执行.</li>
<li>millis Time-该命令执行耗时，以毫秒记.</li>
<li>info-本命令的详细信息.</li>
<li>query-表明这是一个query查询操作.</li>
<li>ntoreturn-本次查询客户端要求返回的记录数.比如, findOne()命令执行时 ntoreturn 为 1.有limit(n) 条件时ntoreturn为n.</li>
<li>query-具体的查询条件(如x&gt;3).</li>
<li>nscanned-本次查询扫描的记录数.</li>
<li>reslen-返回结果集的大小.</li>
<li>nreturned-本次查询实际返回的结果集.</li>
<li>update-表明这是一个update更新操作.</li>
<li>fastmod-Indicates a fast modify operation. See Updates. These operations are normally quite fast.</li>
<li>fastmodinsert – indicates a fast modify operation that performed an upsert.</li>
<li>upsert-表明update的upsert参数为true.此参数的功能是如果update的记录不存在，则用update的条件insert一条记录.</li>
<li>moved-表明本次update是否移动了硬盘上的数据，如果新记录比原记录短，通常不会移动当前记录，如果新记录比原记录长，那么可能会移动记录到其它位置，这时候会导致相关索引的更新.磁盘操作更多，加上索引更新，会使得这样的操作比较慢.</li>
<li>insert-这是一个insert插入操作.</li>
<li>getmore-这是一个getmore 操作，getmore通常发生在结果集比较大的查询时，第一个query返回了部分结果，后续的结果是通过getmore来获取的。<br>注：查询慢查询需要连接到具体的数据库才能查询出来。</li>
</ol>
<h2 id="出现原因及解决方案">出现原因及解决方案</h2><p>最终排查出来慢查询主要出现在一个同事最近才加的一张记录调用服务出错日志的表中，没有预料到数据在短短一天增长到400W，查询时并没有添加索引。</p>
<p>最终添加索引之后程序恢复正常。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近公司曲库接入新曲库上线，昨晚高峰期的时候应用报警，上去发现很多MongoTimeoutException异常，该异常最近一直有遇到，原因更是如出一辙，所以这里就记录一下。</p>]]>
    
    </summary>
    
      <category term="DB" scheme="http://xfhnever.com/tags/DB/"/>
    
      <category term="MongoDB" scheme="http://xfhnever.com/tags/MongoDB/"/>
    
      <category term="DB" scheme="http://xfhnever.com/categories/DB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java(十三)-序列化机制]]></title>
    <link href="http://xfhnever.com/2015/10/02/java-serialize/"/>
    <id>http://xfhnever.com/2015/10/02/java-serialize/</id>
    <published>2015-10-02T04:12:34.000Z</published>
    <updated>2015-10-07T07:55:46.000Z</updated>
    <content type="html"><![CDATA[<p>Java序列化是经常使用到的技术，大部分情况下，我只是简单的去实现Serializable接口就算了，今天就简单的了解一下序列化的一些原理。<br><a id="more"></a></p>
<h2 id="概念">概念</h2><p><strong>序列化：</strong> 把Java对象转换为字节序列的过程；</p>
<p><strong>反序列化：</strong> 把字节序列恢复为对象的过程。</p>
<p>使用场景：</p>
<ol>
<li>把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；</li>
<li>在网络上传送对象的字节序列（远程通信）。</li>
</ol>
<h2 id="如何序列化一个对象">如何序列化一个对象</h2><p>一个对象如果想实现序列化只需实现java.io.Serializable接口，该接口没有方法，只是一种标记。java.io.ObjectOutputStream类中的writeObject0方法如下：</p>
<pre><code><span class="keyword">private</span> <span class="keyword">void</span> writeObject0(<span class="keyword">Object</span> obj, <span class="built_in">boolean</span> unshared)
    <span class="keyword">throws</span> IOException
{
    <span class="comment">// remaining cases</span>
    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="keyword">String</span>) {
        writeString((<span class="keyword">String</span>) obj, unshared);
    } <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) {
        writeArray(obj, desc, unshared);
    } <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) {
        writeEnum((Enum) obj, desc, unshared);
    } <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) {
        writeOrdinaryObject(obj, desc, unshared);
    } <span class="keyword">else</span> {
        <span class="keyword">if</span> (extendedDebugInfo) {
            <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(
                cl.getName() + <span class="string">"\n"</span> + debugInfoStack.toString());
        } <span class="keyword">else</span> {
            <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(cl.getName());
        }
    }
} 
</code></pre><p>由源码可知，如果没有实现java.io.Serializable接口，就会抛出NotSerializableException异常（String、Enum等类也是实现了该接口）。</p>
<p>下面我们举个具体的小例子。我们定义两个类：Animal和Cat类，代码如下：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>{
    <span class="keyword">private</span> <span class="keyword">int</span> type;

    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">()</span> </span>{
        <span class="keyword">this</span>.type = <span class="number">1</span>;
    }
}
</code></pre><p>Cat类：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>{
    <span class="keyword">private</span> String name;

    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> name;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>{
        <span class="keyword">this</span>.name = name;
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>{
        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"out.txt"</span>);
        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);
        Cat cat = <span class="keyword">new</span> Cat();
        cat.setName(<span class="string">"Test"</span>);
        oos.writeObject(cat);
        oos.flush();
        oos.close();

    }
}
</code></pre><p>运行之后，打开out.txt,内容如下：</p>
<pre><code>aced <span class="number">0005</span> <span class="number">7372</span> <span class="number">0012</span> <span class="number">636f</span> <span class="number">6</span>d2e <span class="number">7474</span> <span class="number">706f</span>
<span class="number">642</span>e <span class="number">736f</span> <span class="number">6e67</span> <span class="number">2e43</span> <span class="number">6174</span> <span class="number">4</span>d6e <span class="number">97</span>a6 ab6e
c12e <span class="number">0200</span> <span class="number">014</span>c <span class="number">0004</span> <span class="number">6e61</span> <span class="number">6</span>d65 <span class="number">7400</span> <span class="number">124</span>c
<span class="number">6</span>a61 <span class="number">7661</span> <span class="number">2f</span>6c <span class="number">616</span>e <span class="number">672f</span> <span class="number">5374</span> <span class="number">7269</span> <span class="number">6e67</span>
<span class="number">3</span>b78 <span class="number">7200</span> <span class="number">1563</span> <span class="number">6f</span>6d <span class="number">2e74</span> <span class="number">7470</span> <span class="number">6f</span>64 <span class="number">2e73</span>
<span class="number">6f</span>6e <span class="number">672</span>e <span class="number">416</span>e <span class="number">696</span>d <span class="number">616</span>c a991 <span class="number">5474</span> <span class="number">2068</span>
e443 <span class="number">0200</span> <span class="number">0149</span> <span class="number">0004</span> <span class="number">7479</span> <span class="number">7065</span> <span class="number">7870</span> <span class="number">0000</span>
<span class="number">0001</span> <span class="number">70</span>
</code></pre><p>Java序列化序列化对象的信息包括：类元数据描述、类的属性、父类信息以及属性域的值。Java将这些信息分成3部分：序列化头信息、类的描述部分以及属性域的值部分。现在我们对out.txt加以分析。</p>
<h3 id="序列化头信息">序列化头信息</h3><ol>
<li>0xAC 0xED ：STREAM_MAGIC 流的幻数，用于标记序列化协议</li>
<li>0x00 0x05 ：STREAM_VERSION 标记序列化协议的版本</li>
</ol>
<h3 id="类的描述部分">类的描述部分</h3><ol>
<li>0x73  ： TC_OBJECT. 声明这是一个新的对象</li>
<li>0x72  ： TC_CLASSDESC 声明这是一个新的类描述</li>
<li>0x00 0x12 ：类名字的长度,换算成十进制就是18</li>
<li>0x63 0x6f 0x6d 0x2e 0x74 0x74 0x70 0x6f 0x64 0x2e 0x73 0x6f 0x6e 0x67 0x2e 0x43 0x61 0x74  ： 代表类的名称com.ttpod.song.Cat</li>
<li>0x4d 0x6e 0x97 0xa6 0xab 0x6e 0xc1 0x2e： 序列化ID的类型为long型因此占用8个字节</li>
<li><p>0x02 ：标记号，该字节的8位分表代表不同的含义， </p>
<pre><code><span class="constant">SC_EXTERNALIZABLE</span> <span class="number">0x04</span> <span class="symbol">:</span> 该类实现了java.io.<span class="constant">Externalizable</span>接口 
<span class="constant">SC_BLOCK_DATA</span> <span class="number">0x08</span> <span class="symbol">:</span> <span class="constant">Externalizable</span>接口的writeExternal方法写入的数据
<span class="constant">SC_SERIALIZABLE</span> <span class="number">0x02</span> <span class="symbol">:</span> 该类实现了java.io.<span class="constant">Serializable</span>接口
<span class="constant">SC_WRITE_METHOD</span> <span class="number">0x01</span> <span class="symbol">:</span> 该序列化类实现了writeObject方法 
<span class="constant">SC_ENUM</span> <span class="number">0x10</span> <span class="symbol">:</span> 该类是枚举（<span class="class"><span class="keyword">enum</span>）类型 </span>
</code></pre><p> 该标记号通过上述信息进行或运算（|）而获得。 </p>
</li>
<li>0x00 0x01 ： 代表类属性域的个数 </li>
<li>0x4C ： 域类型，0x4C代表L即该域类型为java对象类型 </li>
<li>0x00 0x04 ： 域名称长度</li>
<li>0x6E 0x61 0x6D 0x65 ：域名称name </li>
<li>0x74 : TC_STRING 一个新字符串</li>
<li>0x00 0x12 ：域类型的长度</li>
<li>0x4C 0x6A 0x61 0x76 0x61 0x2F 0x6C 0x61 0x6E 0x67 0x2F 0x53 0x74 0x72 0x69 0x6E 0x67 0x3B ：对象类型签名Ljava.lang.String</li>
<li>0x78 ： TC_ENDBLOCKDATA 对象数据块结束标志<br>下面是父类描述：</li>
<li>0x72 : TC_CLASSDESC 声明这是一个新的类描述</li>
<li>0x00 0x15 : 类名长度，换算成十进制就是21  </li>
<li>0x63 0x6f 0x6d 0x2e 0x74 0x74 0x70 0x6f 0x64 0x2e 0x73 0x6f 0x6e 0x67 0x2e 0x41 0x6e 0x69 0x6d 0x61 0x6c ： 代表类的名称com.ttpod.song.Aniaml</li>
<li>0xa9 0x91 0x54 0x74 0x20 0x68 0xe4 0x43  ： 序列化ID </li>
<li>0x02 ： 标记号</li>
<li>0x00 0x01 ： 域个数 </li>
<li>0x49 ： 域类型，0x49代表I即int类型</li>
<li>0x00 0x04 ： 域名称长度</li>
<li>0x74 0x79 0x70 0x65 ： 域名称type</li>
<li>0x78 ： TC_ENDBLOCKDATA 对象数据块结束标志</li>
<li>0x70 ： TC_NULL 再没有父类的标志</li>
</ol>
<h3 id="属性域的值部分">属性域的值部分</h3><ol>
<li>0x00 0x00 0x00 0x01 : 父类域type的值为1</li>
<li>0x74 ：TC_STRING 一个新字符串</li>
<li>0x00 0x04 ：域值的长度，十进制为4</li>
<li>0x54 0x65 0x73 0x74 ： name值为Test</li>
</ol>
<p>由上可知，Java序列化的算法的基本步骤如下：</p>
<ol>
<li>输出序列化的头部信息，包括标识序列化协议的幻数以及协议的版本； </li>
<li>按照由子类到父类的顺序，递归的输出类的描述信息，直到不再有父类为止；类描述信息按照类元数据，类属性信息的顺序写入序列化流中； </li>
<li>按照由父类到子类的顺序，递归的输出对象域的实际数据值；而对象的属性信息是按照基本数据类型到java对象类型的顺序写入序列化流中；其中java对象类型的属性会从步骤a)重新开始递归的输出，直到不再存在java对象类型的属性。</li>
</ol>
<h2 id="更多">更多</h2><h3 id="序列化ID的问题">序列化ID的问题</h3><p>序列化ID提供了两种生成策略，一个是固定的 1L，一个是随机生成一个不重复的 long 类型数据（实际上是使用JDK工具生成）。虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致。所以这里强烈建议在一个可序列化类中显示的定义serialVersionUID，为它赋予明确的值。</p>
<h3 id="静态变量序列化">静态变量序列化</h3><p>序列化并不保存静态变量。序列化保存的是对象的状态，静态变量属于类的状态。</p>
<h3 id="父类的序列化与_Transient_关键字">父类的序列化与 Transient 关键字</h3><p>要想将父类对象也序列化，就需要让父类也实现Serializable 接口。如果父类不实现的话的，就 需要有默认的无参的构造函数。在父类没有实现 Serializable 接口时，虚拟机是不会序列化父对象的，而一个 Java 对象的构造必须先有父对象，才有子对象，反序列化也不例外。所以反序列化时，为了构造父对象，只能调用父类的无参构造函数作为默认的父对象。因此当我们取父对象的变量值时，它的值是调用父类无参构造函数后的值。如果你考虑到这种序列化的情况，在父类无参构造函数中对变量进行初始化，否则的话，父类变量值都是默认声明的值，如 int 型的默认是 0，string 型的默认是 null。</p>
<p>Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。</p>
<h3 id="序列化存储规则">序列化存储规则</h3><p>Java 序列化机制为了节省磁盘空间，具有特定的存储规则，当写入文件的为同一对象时，并不会再将对象的内容进行存储，而只是再次存储一份引用。</p>
<h2 id="其他序列化协议">其他序列化协议</h2><p>由上面分析我们发现Java序列化储存了很多我们并不关系的内容，所以占用空间比较大。下面我们再介绍几种其他协议，不过目前暂时还没有实践过，等实践之后再详细介绍，目前只贴几个链接。</p>
<ol>
<li><a href="http://code.google.com/p/protobuf/" target="_blank" rel="external">protocol buffers</a></li>
<li><a href="http://hessian.caucho.com/index.xtp" target="_blank" rel="external">hessian</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>Java序列化是经常使用到的技术，大部分情况下，我只是简单的去实现Serializable接口就算了，今天就简单的了解一下序列化的一些原理。<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://xfhnever.com/tags/Java/"/>
    
      <category term="序列化" scheme="http://xfhnever.com/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
      <category term="Java" scheme="http://xfhnever.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[maven(五)-plugins]]></title>
    <link href="http://xfhnever.com/2015/10/02/maven-plugins/"/>
    <id>http://xfhnever.com/2015/10/02/maven-plugins/</id>
    <published>2015-10-02T01:36:20.000Z</published>
    <updated>2015-10-02T05:22:36.000Z</updated>
    <content type="html"><![CDATA[<p>使用Maven构建项目，经常会在POM文件build标签中用到各种plugin，这里就整理一下经常使用到的插件的用途。<br><a id="more"></a><br>Maven本质上是一个插件框架，它的核心并不执行任何具体的构建任务，所有这些任务都交给插件来完成，例如编译源代码是由maven- compiler-plugin完成的。进一步说，每个任务对应了一个插件目标（goal），每个插件会有一个或者多个目标，例如maven- compiler-plugin的compile目标用来编译位于src/main/java/目录下的主源码，testCompile目标用来编译位于src/test/java/目录下的测试源码。</p>
<p>用户可以通过两种方式调用Maven插件目标。第一种方式是将插件目标与生命周期阶段（lifecycle phase）绑定，这样用户在命令行只是输入生命周期阶段而已，例如Maven默认将maven-compiler-plugin的compile目标与 compile生命周期阶段绑定，因此命令mvn compile实际上是先定位到compile这一生命周期阶段，然后再根据绑定关系调用maven-compiler-plugin的compile目标。第二种方式是直接在命令行指定要执行的插件目标，例如mvn archetype:generate 就表示调用maven-archetype-plugin的generate目标，这种带冒号的调用方式与生命周期无关。</p>
<h2 id="maven-compiler-plugin">maven-compiler-plugin</h2><p>用来编译项目，可以指定编译时的JDK版本、编码方式等。包含两个目标：compile目标用来编译位于src/main/java/目录下的主源码，testCompile目标用来编译位于src/test/java/目录下的测试源码。</p>
<h2 id="maven-resources-plugin">maven-resources-plugin</h2><p>为了使项目结构更为清晰，Maven区别对待Java代码文件和资源文件，maven-compiler-plugin用来编译Java代码，maven-resources-plugin则用来处理资源文件。默认的主资源文件目录是src/main/resources，很多用户会需要添加额外的资源文件目录，这个时候就可以通过配置maven-resources-plugin来实现。此外，资源文件过滤也是Maven的一大特性，你可以在资源文件中使用${propertyName}形式的Maven属性，然后配置maven-resources-plugin开启对资源文件的过滤，之后就可以针对不同环境通过命令行或者Profile传入属性的值，以实现更为灵活的构建。</p>
<h2 id="maven-source-plugin">maven-source-plugin</h2><p>生成源码包</p>
<h2 id="maven-javadoc-plugin">maven-javadoc-plugin</h2><p>生成JavaDoc文档。</p>
<h2 id="maven-jar-plugin">maven-jar-plugin</h2><p>进行打包,只包含了编译生成的.class文件和项目资源文件，不可以直接运行。</p>
<h2 id="maven-deploy-plugin">maven-deploy-plugin</h2><p>发布插件</p>
<h2 id="maven-shade-plugin">maven-shade-plugin</h2><p>除了前面提到了常规JAR包、WAR包，源码包和Javadoc包，另一种常被用到的包是在命令行可直接运行的CLI（Command Line）包。默认Maven生成的JAR包只包含了编译生成的.class文件和项目资源文件，而要得到一个可以直接在命令行通过java命令运行的JAR文件，还要满足两个条件：</p>
<ol>
<li>JAR包中的/META-INF/MANIFEST.MF元数据文件必须包含Main-Class信息。</li>
<li>项目所有的依赖都必须在Classpath中。</li>
</ol>
<p>maven-shade-plugin插件能帮助用户完成上述任务,它可以让用户配置Main-Class的值，然后在打包的时候将值填入/META-INF/MANIFEST.MF文件。</p>
<h2 id="maven-assembly-plugin">maven-assembly-plugin</h2><p>maven-assembly-plugin的用途是制作项目分发包，该分发包可能包含了项目的可执行文件、源代码、readme、平台脚本等等。 maven-assembly-plugin支持各种主流的格式如zip、tar.gz、jar和war等，具体打包哪些文件是高度可控的，例如用户可以 按文件级别的粒度、文件集级别的粒度、模块级别的粒度、以及依赖级别的粒度控制打包，此外，包含和排除配置也是支持的。maven-assembly- plugin要求用户使用一个名为assembly.xml的元数据文件来表述打包，它的single目标可以直接在命令行调用，也可以被绑定至生命周期。</p>
<h2 id="maven-surefire-plugin">maven-surefire-plugin</h2><p>surefire 插件用来在maven构建生命周期的test phase执行一个应用的单元测试。只要测试类遵循通用的命令约定（以Test结尾、以TestCase结尾、或者以Test开头），就几乎不用知晓该插件的存在。然而在当你想要跳过测试、排除某些 测试类、或者使用一些TestNG特性的时候，了解maven-surefire-plugin的一些配置选项就很有用了。</p>
<h2 id="exec-maven-plugin">exec-maven-plugin</h2><p>exec-maven-plugin很好理解，顾名思义，它能让你运行任何本地的系统程序，在某些特定情况下，运行一个Maven外部的程序可能就是最简单的问题解决方案，这就是exec:exec的 用途，当然，该插件还允许你配置相关的程序运行参数。除了exec目标之外，exec-maven-plugin还提供了一个java目标，该目标要求你 提供一个mainClass参数，然后它能够利用当前项目的依赖作为classpath，在同一个JVM中运行该mainClass。有时候，为了简单的 演示一个命令行Java程序，你可以在POM中配置好exec-maven-plugin的相关运行参数，然后直接在命令运行 mvn exec:java 以查看运行效果。</p>
<h2 id="参考">参考</h2><ol>
<li><a href="http://maven.apache.org/plugins/index.html#" target="_blank" rel="external">Maven-Available Plugins</a></li>
<li><a href="http://www.mojohaus.org/" target="_blank" rel="external"> MojoHaus Maven Plugins Project</a></li>
<li><a href="http://www.cnblogs.com/crazy-fox/archive/2012/02/09/2343722.html" target="_blank" rel="external">常用Maven插件介绍</a></li>
<li><a href="http://www.infoq.com/cn/news/2011/06/xxb-maven-9-package/" target="_blank" rel="external">Maven实战（九）——打包的技巧</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>使用Maven构建项目，经常会在POM文件build标签中用到各种plugin，这里就整理一下经常使用到的插件的用途。<br>]]>
    
    </summary>
    
      <category term="Maven" scheme="http://xfhnever.com/tags/Maven/"/>
    
      <category term="plugins" scheme="http://xfhnever.com/tags/plugins/"/>
    
      <category term="Maven" scheme="http://xfhnever.com/categories/Maven/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Blog(四)--Hexo博客的进一步配置]]></title>
    <link href="http://xfhnever.com/2015/10/01/blog-hexo-setting/"/>
    <id>http://xfhnever.com/2015/10/01/blog-hexo-setting/</id>
    <published>2015-10-01T01:24:01.000Z</published>
    <updated>2015-10-01T16:13:48.000Z</updated>
    <content type="html"><![CDATA[<p>最近将自己博客从Octopress迁移到了Hexo，使用jacman主题，下一步就是做一些个性化的配置啦。<br><a id="more"></a></p>
<h2 id="添加评论">添加评论</h2><p>hexo默认使用disqus，不过国内的话还是比较推荐<a href="http://duoshuo.com/" target="_blank" rel="external">多说</a>。</p>
<h3 id="步骤">步骤</h3><ol>
<li>在多说进行注册，获得通用代码。</li>
<li><p>在_config.yml中添加多说的配置</p>
<pre><code><span class="string">duoshuo_shortname:</span> 你站点的short_name  
<span class="comment">//这里的short_name也就是你的二级域名</span>
</code></pre></li>
<li>将通用代码粘贴到themes\landscape\layout_partial\article.ejs中，如果不是默认主题landscape，需要修改 主题\layout_partial\comment.ejs,比如jacman主题是修改的\themes\jacman\layout_partial\post\comment.ejs配置。</li>
</ol>
<p><em>注:</em> jacman主题直接使用官网的的配置会提示post没有定义，可以将所有post修改为item。</p>
<h3 id="自定义CSS">自定义CSS</h3><p>添加完多说评论之后发现评论区域特别丑，于是简单的调整了一下CSS。</p>
<ol>
<li><p>评论框左右边距</p>
<pre><code><span class="id">#ds-thread</span> <span class="rules">{
    <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">14px</span> <span class="number">34px</span></span></span>;
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#ffffff</span></span></span>;
}</span>
</code></pre></li>
<li><p>区分评论区域</p>
<pre><code><span class="tag">section</span><span class="id">#comments</span> <span class="rules">{
    <span class="rule"><span class="attribute">border-top</span>:<span class="value"> <span class="number">25px</span> solid <span class="hexcolor">#ddd</span></span></span>;
}</span>
</code></pre></li>
<li><p>隐藏底部多说版权</p>
<pre><code><span class="id">#ds-thread</span> <span class="id">#ds-reset</span> <span class="class">.ds-powered-by</span><span class="rules">{
    <span class="rule"><span class="attribute">display</span>:<span class="value">none</span></span>;
}</span>
</code></pre></li>
</ol>
<h2 id="生成post时默认生成categories配置项">生成post时默认生成categories配置项</h2><p>在scaffolds/post.md中，添加一行categories:</p>
<h2 id="添加标签云widget">添加标签云widget</h2><p>在themes/jacman/_config.yml中，添加如下：</p>
<pre><code>widgets:
<span class="bullet">- </span>tagcloud
</code></pre><h2 id="统计">统计</h2><h3 id="百度统计">百度统计</h3><ol>
<li>注册<a href="http://tongji.baidu.com/web/welcome/login" target="_blank" rel="external">百度统计</a>账号</li>
<li><p>修改themes/jacman/_config.yml</p>
<pre><code><span class="attribute">baidu_tongji</span>:
      <span class="attribute">enable</span>: true
      <span class="attribute">sitecode</span>:  your site's code <span class="comment">//百度统计为你的网站随机生成的code</span>
</code></pre></li>
<li>验证：百度统计上面有代码安装检查，配置完成之后再check一下。</li>
<li>去除多余的百度logo：安装完成之后发现页面左下角有个百度logo，可以进入网站中心-&gt;系统管理设置-&gt;统计图表设置目录，去掉显示图表的勾选即可。</li>
</ol>
<p><em>注:</em> 其他模版做法可能略有不同，下面附上其他的方案。  </p>
<h3 id="谷歌统计">谷歌统计</h3><p>类似于上面百度统计。    </p>
<h2 id="Sitemap插件">Sitemap插件</h2><ol>
<li><p>安装插件</p>
<pre><code>npm <span class="operator"><span class="keyword">install</span> hexo-generator-sitemap <span class="comment">--save</span></span>
</code></pre></li>
<li><p>修改hexo_config.yml</p>
<pre><code><span class="label">plugins:</span>
    -hexo-generator-sitemap  <span class="preprocessor">#插件名 </span>
</code></pre></li>
</ol>
<h2 id="搜索引擎">搜索引擎</h2><p>可以到<a href="http://www.sousuoyinqingtijiao.com/" target="_blank" rel="external">屈站长</a>提交你的站点给搜索引擎</p>
<h2 id="统计功能">统计功能</h2><ol>
<li><p>向themes/你的主题/layout/_partial/footer.ejs添加busuanzi.js</p>
<pre><code><span class="tag">&lt;<span class="title">script</span> <span class="attribute">async</span> <span class="attribute">src</span>=<span class="value">"https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;</span><span class="undefined">
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre></li>
<li><p>安装标签</p>
<p> themes/你的主题/layout/_partial/footer.ejs中添加</p>
<pre><code><span class="tag">&lt;<span class="title">span</span> <span class="attribute">id</span>=<span class="value">"busuanzi_container_site_uv"</span>&gt;</span>
  本站访客数<span class="tag">&lt;<span class="title">span</span> <span class="attribute">id</span>=<span class="value">"busuanzi_value_site_uv"</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span>人次
<span class="tag">&lt;/<span class="title">span</span>&gt;</span>
</code></pre><p> 详情请参考<a href="http://ibruce.info/2015/04/04/busuanzi/" target="_blank" rel="external">为hexo博客添加访问次数统计功能</a></p>
</li>
</ol>
<h2 id="参考">参考</h2><ol>
<li><a href="http://dev.duoshuo.com/threads/541d3b2b40b5abcd2e4df0e9" target="_blank" rel="external">Hexo使用多说教程</a></li>
<li><a href="http://dev.duoshuo.com/docs/4ff1cfd0397309552c000017" target="_blank" rel="external">多说CSS修改</a></li>
<li><a href="http://www.lichanglin.cn/%E5%9C%A8hexo%E4%B8%AD%E5%8A%A0%E5%85%A5%E5%A4%9A%E8%AF%B4%E8%AF%84%E8%AE%BA/" target="_blank" rel="external">在hexo中加入多说评论</a></li>
<li><a href="http://blog.justforfun.top/2015/02/06/hexo-%E6%B7%BB%E5%8A%A0%E7%99%BE%E5%BA%A6%E7%BB%9F%E8%AE%A1/" target="_blank" rel="external">hexo 添加百度统计</a></li>
<li><a href="https://github.com/hexojs/hexo/wiki/Plugins" target="_blank" rel="external">hexojs/hexo</a></li>
<li><a href="https://github.com/hexojs/hexo/wiki/Plugins" target="_blank" rel="external">hexo/Plugins</a></li>
<li><a href="http://ibruce.info/2015/04/04/busuanzi/" target="_blank" rel="external">为hexo博客添加访问次数统计功能</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近将自己博客从Octopress迁移到了Hexo，使用jacman主题，下一步就是做一些个性化的配置啦。<br>]]>
    
    </summary>
    
      <category term="Blog" scheme="http://xfhnever.com/tags/Blog/"/>
    
      <category term="Hexo" scheme="http://xfhnever.com/tags/Hexo/"/>
    
      <category term="Blog" scheme="http://xfhnever.com/categories/Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[log(二) - java中log体系再讨论]]></title>
    <link href="http://xfhnever.com/2015/09/20/log-java-2/"/>
    <id>http://xfhnever.com/2015/09/20/log-java-2/</id>
    <published>2015-09-20T02:34:01.000Z</published>
    <updated>2015-10-01T12:30:13.000Z</updated>
    <content type="html"><![CDATA[<p>虽然之前已经介绍过Java中的log，但是目前使用的过程中依然傻傻分不清，决定再次整理和介绍一下。<br><a id="more"></a></p>
<h2 id="各种log框架">各种log框架</h2><p>实际项目中我们经常可以看到log4j、logback、slf4j等框架的身影，对于这些乱七八糟的log框架大致可以分为两个种类：</p>
<p><strong>日志框架</strong>：jdk自带的logging(jul)，log4j1、log4j2、logback</p>
<p><strong>用于实现日志统一的框架</strong>： apache的commons-logging(jcl)、slf4j</p>
<h3 id="log4j1和log4j2">log4j1和log4j2</h3><p>log4j2与log4j1发生了很大的变化，不兼容。log4j1仅仅作为一个实际的日志框架，slf4j、commons-logging作为门面，统一各种日志框架的混乱格局，现在log4j2也想跳出来充当门面了，也想统一大家了。</p>
<p>log4j2分成2个部分：</p>
<ol>
<li>log4j-api： 作为日志接口层，用于统一底层日志系统</li>
<li>log4j-core : 作为上述日志接口的实现，是一个实际的日志框架</li>
</ol>
<h3 id="各种jar包总结">各种jar包总结</h3><p><strong>log4j1</strong>:</p>
<ol>
<li>log4j：log4j1的全部内容</li>
</ol>
<p><strong>log4j2</strong>:</p>
<ol>
<li>log4j-api:log4j2定义的API</li>
<li>log4j-core:log4j2上述API的实现</li>
</ol>
<p><strong>logback</strong>:</p>
<ol>
<li>logback-core:logback的核心包</li>
<li>logback-classic：logback实现了slf4j的API</li>
</ol>
<p><strong>commons-logging</strong>:</p>
<ol>
<li>commons-logging:commons-logging的原生全部内容</li>
<li>log4j-jcl:commons-logging到log4j2的桥梁</li>
<li>jcl-over-slf4j：commons-logging到slf4j的桥梁</li>
</ol>
<p><strong>slf4j转向某个实际的日志框架</strong>:</p>
<p>场景介绍：如 使用slf4j的API进行编程，底层想使用log4j1来进行实际的日志输出，这就是slf4j-log4j12干的事。</p>
<ol>
<li>slf4j-jdk14：slf4j到jdk-logging的桥梁</li>
<li>slf4j-log4j12：slf4j到log4j1的桥梁</li>
<li>log4j-slf4j-impl：slf4j到log4j2的桥梁</li>
<li>logback-classic：slf4j到logback的桥梁</li>
<li>slf4j-jcl：slf4j到commons-logging的桥梁</li>
</ol>
<p><strong>某个实际的日志框架转向slf4j</strong>：</p>
<p>场景介绍：如 使用log4j1的API进行编程，但是想最终通过logback来进行输出，所以就需要先将log4j1的日志输出转交给slf4j来输出，slf4j再交给logback来输出。将log4j1的输出转给slf4j，这就是log4j-over-slf4j做的事。这一部分主要用来进行实际的日志框架之间的切换。</p>
<ol>
<li>jul-to-slf4j：jdk-logging到slf4j的桥梁</li>
<li>log4j-over-slf4j：log4j1到slf4j的桥梁</li>
<li>jcl-over-slf4j：commons-logging到slf4j的桥梁</li>
</ol>
<h2 id="jcl与日志框架的集成">jcl与日志框架的集成</h2><pre><code><span class="keyword">private</span> <span class="keyword">static</span> Log logger=LogFactory.getLog(Test.<span class="keyword">class</span>);
</code></pre><h3 id="jul">jul</h3><p><strong>需要jar包</strong>：</p>
<ol>
<li>commons-logging</li>
</ol>
<h3 id="log4j1">log4j1</h3><p><strong>需要jar包</strong>：</p>
<ol>
<li>commons-logging</li>
<li>log4j</li>
</ol>
<h3 id="log4j2">log4j2</h3><p><strong>需要jar包</strong>：</p>
<ol>
<li>commons-logging</li>
<li>log4j-api  （log4j2的API包）</li>
<li>log4j-core （log4j2的API实现包）</li>
<li>log4j-jcl  （log4j2与commons-logging的集成包）</li>
</ol>
<h3 id="logback">logback</h3><p><strong>需要jar包</strong>：</p>
<ol>
<li>jcl-over-slf4j (替代了commons-logging)</li>
<li>slf4j-api</li>
<li>logback-core</li>
<li>logback-classic</li>
</ol>
<p>logback本身的使用其实就和slf4j绑定了起来，现在要想指定commons-logging的底层log实现是logback，则需要2步走</p>
<ol>
<li>先将commons-logging底层的log实现转向slf4j (jcl-over-slf4j干的事)</li>
<li>再根据slf4j的选择底层日志原理，我们使之选择上logback</li>
</ol>
<h2 id="slf4j与日志框架的集成">slf4j与日志框架的集成</h2><pre><code><span class="keyword">private</span> <span class="keyword">static</span> Logger logger=LoggerFactory.getLogger(Test.<span class="keyword">class</span>);
</code></pre><h3 id="jul-1">jul</h3><p><strong>需要jar包</strong>：</p>
<ol>
<li>slf4j-api</li>
<li>slf4j-jdk14</li>
</ol>
<h3 id="log4j1-1">log4j1</h3><p><strong>需要jar包</strong>：</p>
<ol>
<li>slf4j-api</li>
<li>slf4j-log4j12</li>
<li>log4j</li>
</ol>
<h3 id="log4j2-1">log4j2</h3><p><strong>需要jar包</strong>：</p>
<ol>
<li>slf4j-api</li>
<li>log4j-api</li>
<li>log4j-core</li>
<li>log4j-slf4j-impl （用于log4j2与slf4j集成）</li>
</ol>
<h3 id="logback-1">logback</h3><p><strong>需要jar包</strong>：</p>
<ol>
<li>slf4j-api</li>
<li>logback-core</li>
<li>logback-classic（已含有对slf4j的集成包）</li>
</ol>
<h2 id="总结">总结</h2><p>由上面我们可以发现一个完整的Log日志主要包括如下三个部分：</p>
<ol>
<li>接口：sfl4j-api-xxx.jar</li>
<li>实现，也就是具体的日志框架：log4-xxx.jar、logback等</li>
<li>适配层：slf4j-log4j12-xxx.jar</li>
</ol>
<h3 id="问题">问题</h3><pre><code><span class="label">SLF4J:</span> Failed to load class <span class="string">"org.slf4j.impl.StaticLoggerBinder"</span>.
<span class="label">SLF4J:</span> Defaulting to no-operation (<span class="keyword">NOP</span>) logger implementation
<span class="label">SLF4J:</span> See http://www.slf4j<span class="preprocessor">.org</span>/codes.html<span class="preprocessor">#StaticLoggerBinder for further details.</span>
</code></pre><p>如果启动应用/程序的时候，报这样的错。那说明上面提到的sfl4j-log4j12没有依赖。需要在pom.xml显式的引入。</p>
<h2 id="日志最佳实践">日志最佳实践</h2><ol>
<li><p>检查日志是否可以被记录</p>
<pre><code> <span class="preprocessor">if</span> (LOGGER.isDebugEnabled()) { 
        LOGGER.debug(<span class="string">"This is a message."</span>)<span class="comment">; </span>
    }
作用在于避免了构造日志记录消息所带来的开销。日志消息中通常包含与当前上下文相关的信息。为了获取这些信息并构造相应的消息文本，不可避免会产生额外的开销。因此在记录 <span class="preprocessor">INFO</span>、DEBUG 和 TRACE 级别的日志时，首先进行相应的检查是一个好的实践。而 WARN 及其以上级别的日志则一般不需要进行检查。
</code></pre></li>
<li><p>日志中包含充分的信息。保证可读性，需记录现场信息，如当前处理id等 </p>
</li>
<li>绝不要打印没有用的日志，防止无用日志淹没重要信息</li>
<li>日志格式要统一规范  </li>
<li>用log.error表示系统级错误（不可预测）;用log.warn表示应用级错误（可预测）;服务初始化或结束用log.info;用log.warn(“”,e)替代e.printstack</li>
</ol>
<h2 id="参考">参考</h2><ol>
<li><a href="http://my.oschina.net/pingpangkuangmo/blog/406618" target="_blank" rel="external">jdk-logging、log4j、logback日志介绍及原理</a></li>
<li><a href="http://www.atatech.org/articles/15129" target="_blank" rel="external">java日志系统指南</a></li>
<li><a href="http://blog.jobbole.com/51155/" target="_blank" rel="external">Java 日志管理最佳实践</a></li>
<li><a href="http://blog.jobbole.com/56574/" target="_blank" rel="external">王健：最佳日志实践</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>虽然之前已经介绍过Java中的log，但是目前使用的过程中依然傻傻分不清，决定再次整理和介绍一下。<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://xfhnever.com/tags/Java/"/>
    
      <category term="Log" scheme="http://xfhnever.com/tags/Log/"/>
    
      <category term="Java" scheme="http://xfhnever.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java(十二) - Exception]]></title>
    <link href="http://xfhnever.com/2015/09/19/java-exception/"/>
    <id>http://xfhnever.com/2015/09/19/java-exception/</id>
    <published>2015-09-19T08:55:24.000Z</published>
    <updated>2015-10-01T12:33:20.000Z</updated>
    <content type="html"><![CDATA[<p>java中的Exception是面试中经常被问到的模块，虽然每次都能或多或少的讲出一些内容，但是直到最近才开始在编程实践中应用起来。良好的使用Exception能让程序bug更少，更加健壮。<br><a id="more"></a></p>
<h2 id="Java的异常">Java的异常</h2><img src="/images/post/java12-1.jpg">
<p><strong>Throwable</strong>：有两个重要的子类：Exception（异常）和 Error（错误），二者都是 Java 异常处理的重要子类，各自都包含大量子类。 </p>
<p><strong>Error</strong>: 是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。</p>
<p><strong>Exception</strong>: 是程序本身可以处理的异常。这种异常分两大类运行时异常和非运行时异常，程序中应当尽可能去处理这些异常。 </p>
<h3 id="异常分类">异常分类</h3><p><strong>可查的异常（checked exceptions）</strong>: 除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</p>
<p><strong>不可查的异常（unchecked exceptions）</strong>: 包括运行时异常（RuntimeException与其子类）和错误（Error）</p>
<p>由上可知， Exception 这种异常分两大类运行时异常和非运行时异常(编译异常)。程序中应当尽可能去处理这些异常。</p>
<p><strong>运行时异常</strong>：这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。</p>
<p><strong>非运行时异常 （编译异常）</strong>：是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p>
<h2 id="处理异常机制">处理异常机制</h2><p>异常处理机制为：抛出异常，捕捉异常。</p>
<h3 id="捕捉异常">捕捉异常</h3><pre><code><span class="tag">try</span>{
  <span class="comment">//（尝试运行的）程序代码</span>
}<span class="tag">catch</span>(异常类型 异常的变量名){
  <span class="comment">//异常处理代码</span>
}<span class="tag">finally</span>{
  <span class="comment">//异常发生，方法返回之前，总是要执行的代码</span>
}
</code></pre><h3 id="抛出异常">抛出异常</h3><pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{
    <span class="comment">//抛出一个检查异常</span>
    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"方法test3中的Exception"</span>);
} 
</code></pre><p><strong>throw</strong>关键字是用于方法体内部，用来抛出一个Throwable类型的异常。如果抛出了检查异常,则还应该在方法头部声明方法可能抛出的异常类型。该方法的调用者也必须检查处理抛出的异常。如果所有方法都层层上抛获取的异常，最终JVM会进行处理，处理也很简单，就是打印异常消息和堆栈信息。如果抛出的是Error或RuntimeException，则该方法的调用者可选择处理该异常。</p>
<p><strong>throws</strong>关键字用于方法体外部的方法声明部分，用来声明方法可能会抛出某些异常。仅当抛出了检查异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣一般在catch块中打印一下堆栈信息做个勉强处理。</p>
<h3 id="return语句的执行顺序">return语句的执行顺序</h3><ol>
<li>如果finally{}块中有return语句，只执行finally{}块中的return语句</li>
<li>如果finally{}块中没有return语句，如果try{}有异常，则返回catch{}中的return语句，不然执行try{}中return语句，在这种情况下，return语句块是在finally{}之后执行</li>
</ol>
<p>return并不是让函数马上返回，而是return语句执行后，将返回结果放置进函数栈中，此时函数并不是马上返回，它要执行finally语句后才真正开始返回。</p>
<h2 id="异常的转译与异常链">异常的转译与异常链</h2><h3 id="异常转译">异常转译</h3><p>谓的异常转译就是将一种异常转换另一种新的异常，也许这种新的异常更能准确表达程序发生异常。 </p>
<p>几乎所有带异常原因的异常构造方法都使用Throwable类型做参数，这也就为异常的转译提供了直接的支持，因为任何形式的异常和错误都Throwable的子类。</p>
<h3 id="异常链">异常链</h3><p>异常链顾名思义就是将异常发生的原因一个传一个串起来，即把底层的异常信息传给上层，这样逐层抛出。</p>
<pre><code><span class="keyword">try</span> {         
    doLowerLevelThings();
} <span class="keyword">catch</span> (LowerLevelException cause) {
     <span class="keyword">throw</span> <span class="keyword">new</span> HigherLevelException(cause);
}
</code></pre><p>异常链的实际应用很少，发生异常时候逐层上抛不是个好注意，上层拿到这些异常又能奈之何？而且异常逐层上抛会消耗大量资源，因为要保存一个完整的异常链信息.     </p>
<h2 id="最佳实践">最佳实践</h2><ol>
<li>提早抛出: 越早处理越早隔离异常。</li>
<li>具体明确: 不能通过简单的catch住exception来处理所有异常，而应该捕获具体的异常。</li>
<li>延迟捕获: 不要压制、隐瞒异常。将不能处理的异常往外抛，而不是捕获之后随便处理。捕获之后该拿异常怎么办？最不该做的就是什么都不做。</li>
<li>避免在方法中抛出（throw）或者捕获（catch）运行时异常RuntimeException和Error。</li>
<li>无论服务开发还是服务使用，都要尝试或者想到封装异常，提供友好错误设计的方案，最简单的是自定义一个业务Exception来封装.</li>
</ol>
<p>我们对异常的一个基本期望是异常究竟该被谁捕获，如果被你的服务下游捕获，那么这必须是一个受检的异常，如果是系统自身需要，那么这个我个人认为是分阶段设计的，在初期，也就是未发布状态，这些Exception应该总是被抛出的，因为这样可以快速的让测试和质量控制人员发现系统崩溃的点。在发布阶段，异常可能需要被内部消化，这时受检异常就要提供给业务系统，让业务开发自行捕获异常。当然，好的系统架构可能会把Exception作为一个内部可见外部不可见的内容，而基于此完全封装一套error code对外，这应该算是比较友好的做法了，也是很多API设计时的标准规范。毕竟对外部透明，不要让用户看到你的Exception，这是非常友好的做法。</p>
<h2 id="参考">参考</h2><ol>
<li><a href="http://blog.csdn.net/hguisu/article/details/6155636" target="_blank" rel="external">深入理解java异常处理机制</a></li>
<li><a href="http://blog.csdn.net/junlixxu/article/details/6096266" target="_blank" rel="external">Java异常体系结构</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>java中的Exception是面试中经常被问到的模块，虽然每次都能或多或少的讲出一些内容，但是直到最近才开始在编程实践中应用起来。良好的使用Exception能让程序bug更少，更加健壮。<br>]]>
    
    </summary>
    
      <category term="Exception" scheme="http://xfhnever.com/tags/Exception/"/>
    
      <category term="Java" scheme="http://xfhnever.com/tags/Java/"/>
    
      <category term="Java" scheme="http://xfhnever.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac(二)- Mac下使用rz、sz]]></title>
    <link href="http://xfhnever.com/2015/09/04/mac-rzsz/"/>
    <id>http://xfhnever.com/2015/09/04/mac-rzsz/</id>
    <published>2015-09-04T14:26:21.000Z</published>
    <updated>2015-10-01T12:35:19.000Z</updated>
    <content type="html"><![CDATA[<p>上传文件到服务器是开发人员经常遇到的事情，在window下我们可以很方面的使用rz、sz命令上传、下载文件，但是mac下一般都是通过scp命令完成，虽然也很方便，但是有些场景下是不能使用的，比如目前公司登录服务器需要经过跳板机，scp命令就不再适用。所以本篇我们就介绍一下如何在mac下使用rz、sz上传下载文件。<br><a id="more"></a></p>
<h2 id="scp命令介绍">scp命令介绍</h2><p>首先我们先介绍一下mac下的scp命令。</p>
<h3 id="上传">上传</h3><pre><code>scp -r local_folder remote_username<span class="variable">@remote_ip</span><span class="symbol">:remote_folder</span>
</code></pre><p>或者</p>
<pre><code>scp -r <span class="built_in">local</span>_folder remote_ip:remote_folder
</code></pre><h3 id="下载">下载</h3><p>下载和上传对应，只需要修改后两个参数顺序即可，即调整源文件和目标文件顺序。</p>
<pre><code>scp -r remote_username<span class="variable">@remote_ip</span><span class="symbol">:remote_folder</span> local_folder 
</code></pre><h3 id="几个可能用到的参数">几个可能用到的参数</h3><ol>
<li>-v 和大多数 linux 命令中的 -v 意思一样 , 用来显示进度 . 可以用来查看连接 , 认证 , 或是配置错误 .</li>
<li>-r 　递归处理，将指定目录下的文档和子目录一并处理</li>
<li>-C 使能压缩选项 .</li>
<li>-P 选择端口 . 注意 -p 已经被 rcp 使用 .</li>
<li>-4 强行使用 IPV4 地址 .</li>
<li>-6 强行使用 IPV6 地址 .    </li>
</ol>
<h2 id="mac下如何配置才能使用rz、sz">mac下如何配置才能使用rz、sz</h2><h3 id="安装Iterm2">安装Iterm2</h3><pre><code><span class="keyword">brew </span>install lrzsz
</code></pre><h3 id="下载iterm2-zmodem">下载iterm2-zmodem</h3><pre><code>cd /usr/local/bin

sudo wget <span class="symbol">https:</span>/<span class="regexp">/raw.github.com/mmastrac</span><span class="regexp">/iterm2-zmodem/master</span><span class="regexp">/iterm2-send-zmodem.sh

sudo wget https:/</span><span class="regexp">/raw.github.com/mmastrac</span><span class="regexp">/iterm2-zmodem/master</span><span class="regexp">/iterm2-recv-zmodem.sh

sudo chmod 777 /usr</span><span class="regexp">/local/bin</span><span class="regexp">/iterm2-*</span>
</code></pre><h3 id="添加trigger">添加trigger</h3><p>打开Item2，点击profiles，选择某个profile之后然后继续选择advanced → triggers，添加triggers。</p>
<table>
<thead>
<tr>
<th>Regular expression</th>
<th style="text-align:center">Action</th>
<th style="text-align:right">Action</th>
</tr>
</thead>
<tbody>
<tr>
<td>\*\*B0100</td>
<td style="text-align:center">Run Silent Coprocess</td>
<td style="text-align:right">/usr/local/bin/iterm2-send-zmodem.sh</td>
</tr>
<tr>
<td>\*\*B00000000000000</td>
<td style="text-align:center">Run Silent Coprocess</td>
<td style="text-align:right">/usr/local/bin/iterm2-recv-zmodem.sh</td>
</tr>
</tbody>
</table>
<h2 id="参考">参考</h2><ol>
<li><a href="http://blog.csdn.net/emili/article/details/6858818" target="_blank" rel="external">linux下不同服务器间数据传输(rcp,scp,rsync,ftp,sftp,lftp,wget,curl)</a></li>
<li><a href="http://www.ipython.me/other/mac-using-lrzsz.html" target="_blank" rel="external">Mac使用rz、sz远程上传下载文件</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>上传文件到服务器是开发人员经常遇到的事情，在window下我们可以很方面的使用rz、sz命令上传、下载文件，但是mac下一般都是通过scp命令完成，虽然也很方便，但是有些场景下是不能使用的，比如目前公司登录服务器需要经过跳板机，scp命令就不再适用。所以本篇我们就介绍一下如何在mac下使用rz、sz上传下载文件。<br>]]>
    
    </summary>
    
      <category term="Mac" scheme="http://xfhnever.com/tags/Mac/"/>
    
      <category term="Tools" scheme="http://xfhnever.com/tags/Tools/"/>
    
      <category term="Tools" scheme="http://xfhnever.com/categories/Tools/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SOA(一)- 介绍]]></title>
    <link href="http://xfhnever.com/2015/04/21/soa-intro/"/>
    <id>http://xfhnever.com/2015/04/21/soa-intro/</id>
    <published>2015-04-21T11:19:31.000Z</published>
    <updated>2015-10-01T12:35:36.000Z</updated>
    <content type="html"><![CDATA[<p>自SOA概念提出之后，越来越多的企业开始使用，之前实习的两家公司都是使用的SOA，对外提供REST风格的接口。所以本文就简单介绍一下SOA的概念。<br><a id="more"></a></p>
<h2 id="什么是SOA">什么是SOA</h2><p>面向服务的体系结构（Service-oriented architecture）是构造分布式计算的应用程序的方法。它将应用程序功能作为服务发送给最终用户或者其他服务。</p>
<p>它采用开放标准、与软件资源进行交互并采用表示的标准方式。</p>
<p>百度文库介绍说面向服务的体系结构是一个组件模型，它将应用程序的不同功能单元（称为服务）通过这些服务之间定义良好的接口和契约联系起来。接口是采用中立的方式进行定义的，它应该独立于实现服务的硬件平台、操作系统和编程语言。这使得构建在各种各样的系统中的服务可以使用一种统一和通用的方式进行交互。</p>
<h2 id="SOA的核心要素">SOA的核心要素</h2><p>SOA的目标就是实现灵活可变的IT系统。要达到灵活性，通过三个途径来解决：标准化封装、复用、松耦合可编排。</p>
<img src="/images/post/soa1-1.jpg">
<h2 id="SOA的原则">SOA的原则</h2><p>以下指导原则是开发，维护和使用SOA的基本原则：</p>
<ol>
<li>可重复使用, 粒度, 模组性, 可组合型, 物件化原件, 构件化以及具交互操作性</li>
<li>符合开放标准(通用的或行业的)</li>
<li>服务的识别和分类，提供和发布，监控和跟踪。</li>
</ol>
<h2 id="服务导向的架构和Web服务协议">服务导向的架构和Web服务协议</h2><p>服务导向的架构通常被定义为通过Web服务协议栈暴露的服务. 与SOA相关的Web服务的标准主要有：</p>
<ol>
<li>XML - 一种标记语言，用于以文档格式描述消息中的数据。</li>
<li>HTTP （或HTTPS） - 客户端和服务端之间用于传送信息而发送请求/回复的协议。</li>
<li>SOAP(Simple Object Access Protocol) - 在计算机网络上交换基于XML的消息的协议，通常是用HTTP。</li>
<li>WSDL(Web Services Description Language) （Web服务描述语言） - 基于XML的描述语言，用于描述与服务交互所需的服务的公共接口，协议绑定，消息格式。</li>
<li>UDDI(Universal Description, Discovery, and Integration) （是统一描述、发现和集成） - 基于XML的注册协议，用于发布WSDL并允许第三方发现这些服务。</li>
</ol>
<p>注意，一个系统要成为服务导向的系统并不需要这些协议，比如一些服务导向的系统可以通过CORBA实现。</p>
<h2 id="参考">参考</h2><ol>
<li><a href="http://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84" target="_blank" rel="external">面向服务的体系结构</a></li>
<li><a href="http://blog.vsharing.com/fengjicheng/A1059842.html" target="_blank" rel="external">浅析深究什么是SOA？</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>自SOA概念提出之后，越来越多的企业开始使用，之前实习的两家公司都是使用的SOA，对外提供REST风格的接口。所以本文就简单介绍一下SOA的概念。<br>]]>
    
    </summary>
    
      <category term="SOA" scheme="http://xfhnever.com/tags/SOA/"/>
    
      <category term="软件工程" scheme="http://xfhnever.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="软件工程" scheme="http://xfhnever.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[VPS(一)- 搭建VPN]]></title>
    <link href="http://xfhnever.com/2015/04/19/vps-vpn/"/>
    <id>http://xfhnever.com/2015/04/19/vps-vpn/</id>
    <published>2015-04-19T04:44:56.000Z</published>
    <updated>2015-10-01T12:36:04.000Z</updated>
    <content type="html"><![CDATA[<p>前段时间买了VPS，然后最近就利用这个搭建了个VPN玩玩，下面就将整个搭建流程纪录一下。<br><a id="more"></a></p>
<h2 id="环境">环境</h2><p>我买的是Linode的VPS，安装的是Centos7系统。</p>
<h2 id="具体步骤">具体步骤</h2><h3 id="检查系统是否开启TUN/TAP支持">检查系统是否开启TUN/TAP支持</h3><pre><code><span class="keyword">cat</span> /dev/<span class="keyword">net</span>/tun
</code></pre><p>如果这条指令显示结果为下面的文本，则表明通过</p>
<pre><code><span class="string">cat:</span> <span class="regexp">/dev/</span>net/<span class="string">tun:</span> 文件描述符处于错误状态
</code></pre><h3 id="安装ppp_,_pptpd_和_iptables">安装ppp , pptpd 和 iptables</h3><pre><code>yum <span class="operator"><span class="keyword">install</span> <span class="keyword">update</span>
yum -y <span class="keyword">install</span> ppp pptpd
yum <span class="keyword">install</span> iptables</span>
</code></pre><h3 id="配置PPTP服务器">配置PPTP服务器</h3><ol>
<li><p>配置pptpd.conf</p>
<pre><code>vi /etc/pptpd.conf    <span class="preprocessor">#找到localip，去掉开始的那个#符号</span>
localip <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>
remoteip <span class="number">192.168</span><span class="number">.0</span><span class="number">.234</span>-<span class="number">238</span>,<span class="number">192.168</span><span class="number">.0</span><span class="number">.245</span>
<span class="preprocessor">#这些是默认的，一般不需要去修改，分配给客户端的ip就是<span class="number">234</span>到<span class="number">238</span>之间，你也可以往大了写，看你的客户端有多少。</span>
</code></pre></li>
<li><p>配置options.pptpd</p>
<pre><code>vi /etc/ppp/options.pptpd      <span class="preprocessor">#在末尾添加dns</span>
ms-dns  <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>       <span class="preprocessor">#这是谷歌的，你也可以改成阿里巴巴的或者其它</span>
ms-dns  <span class="number">8.8</span><span class="number">.4</span><span class="number">.4</span>
</code></pre></li>
<li><p>添加PPTP VPN用户</p>
<pre><code>vi /etc/ppp/chap-secrets    #格式很通俗易懂。
<span class="preprocessor">#   client为帐号，server是pptpd服务，secret是密码，*表示是分配任意的ip</span>
<span class="preprocessor"># Secrets for authentication using CHAP</span>
<span class="preprocessor"># client        server     secret                  IP addresses</span>
  xfhnever      pptpd      <span class="number">771297972</span>            *
</code></pre></li>
<li><p>配置sysctl.conf</p>
<pre><code>vi /etc/sysctl<span class="class">.conf</span>
#添加一行    net<span class="class">.ipv4</span><span class="class">.ip_forward</span> = <span class="number">1</span>    到末尾即可，然后保存
sysctl -<span class="tag">p</span>    #运行这个命令会输出上面添加的那一行信息，意思是使内核修改生效
</code></pre></li>
</ol>
<h3 id="配置iptables">配置iptables</h3><ol>
<li><p>开启iptables转发</p>
<pre><code>iptables -t nat -A POSTROUTING -s <span class="number">192.168</span><span class="number">.217</span><span class="number">.0</span>/<span class="number">24</span> -o eth0 -j MASQUERADE
iptables-save &gt; /etc/iptables.pptp
</code></pre></li>
<li><p>创建iptables文件</p>
<p> 在/etc/network/if-up.d/目录下创建iptables文件，内容如下：</p>
<pre><code><span class="shebang">#!/bin/sh</span>
iptables-restore &lt; /etc/iptables.pptp
</code></pre></li>
<li><p>给脚本添加执行权限</p>
<pre><code>chmod +x <span class="regexp">/etc/</span>network<span class="regexp">/if-up.d/i</span>ptables
</code></pre></li>
</ol>
<h3 id="Done">Done</h3><p>VPN搭建完成。</p>
<h2 id="最新方案">最新方案</h2><p>用了一段时间之后，vpn不稳定，基本连接不上，重新使用了一种新的搭建方案，详见 <a href="http://csli.cc/479.html" target="_blank" rel="external">使用Linode搭建一个Shadowsocks，实现智能和谐上网</a></p>
<h2 id="参考">参考</h2><ol>
<li><a href="http://www.cnblogs.com/qingjoin/p/3811967.html" target="_blank" rel="external">Mac 搭建Linode的 Vps pptp Vpn 服务</a></li>
<li><a href="http://www.open-open.com/lib/view/open1414554734044.html" target="_blank" rel="external">Centos7搭建VPN服务器</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>前段时间买了VPS，然后最近就利用这个搭建了个VPN玩玩，下面就将整个搭建流程纪录一下。<br>]]>
    
    </summary>
    
      <category term="Tools" scheme="http://xfhnever.com/tags/Tools/"/>
    
      <category term="Vpn" scheme="http://xfhnever.com/tags/Vpn/"/>
    
      <category term="Vps" scheme="http://xfhnever.com/tags/Vps/"/>
    
      <category term="Tools" scheme="http://xfhnever.com/categories/Tools/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Avro(四)-RPC]]></title>
    <link href="http://xfhnever.com/2015/03/30/avro-rpc/"/>
    <id>http://xfhnever.com/2015/03/30/avro-rpc/</id>
    <published>2015-03-30T10:04:48.000Z</published>
    <updated>2015-10-01T15:19:25.000Z</updated>
    <content type="html"><![CDATA[<p>Avro除了用于序列化外，还可以作为一种RPC框架来使用。客户端希望同服务器端交互时，就需要交换双方通信的协议，它类似于模式，需要双方来定义，在Avro中被称为消息(Message)。通信双方都必须保持这种协议，以便于解析从对方发送过来的数据，这也就是传说中的握手阶段。<br><a id="more"></a></p>
<h2 id="Message_Transport">Message Transport</h2><p>消息从客户端发送到服务器端需要经过传输层(Transport Layer)，它发送消息并接收服务器端的响应。到达传输层的数据就是二进制数据。通常以HTTP作为传输模型，数据以POST方式发送到对方去。在 Avro中，它的消息被封装成为一组缓冲区(Buffer)，类似于下图的模型：</p>
<img src="/images/post/avro4-1.jpeg">
<p>如上图，每个缓冲区以四个字节开头，中间是多个字节的缓冲数据，最后以一个空缓冲区结尾。这种机制的好处在于，发送端在发送数据时可以很方便地组装不同数据源的数据，接收方也可以将数据存入不同的存储区。还有，当往缓冲区中写数据时，大对象可以独占一个缓冲区，而不是与其它小对象混合存放，便于接收方方便地读取大对象。</p>
<p>对象容器文件是Avro的数据存储的具体实现，数据交换则由RPC服务提供，与对象容器文件类似，数据交换也完全依赖Schema，所以与Hadoop目前的RPC不同，Avro在数据交换之前需要通过握手过程先交换Schema。</p>
<h2 id="握手过程">握手过程</h2><p>握手的过程是确保Server和Client获得对方的Schema定义，从而使Server能够正确反序列化请求信息，Client能够正确反序列化响应信息。一般的，Server/Client会缓存最近使用到的一些协议格式，所以，大多数情况下，握手过程不需要交换整个Schema文本。</p>
<p>所有的RPC请求和响应处理都建立在已经完成握手的基础上。对于无状态的连接，所有的请求响应之前都附有一次握手过程；对于有状态的连接，一次握手完成，整个连接的生命期内都有效。</p>
<h2 id="消息帧格式">消息帧格式</h2><p>消息从客户端发送到服务器端需要经过传输层，它发送请求并接收服务器端的响应。到达传输层的数据就是二进制数据。通常以HTTP作为传输模型，数据以POST方式发送到对方去。在 Avro中消息首先分帧后被封装成为一组缓冲区(Buffer)。</p>
<p>数据帧的格式如下：</p>
<ol>
<li><p>一系列Buffer：</p>
<pre><code><span class="number">4</span>字节的<span class="keyword">Buffer</span>长度
<span class="keyword">Buffer</span>字节数据
</code></pre></li>
<li><p>长度为0的Buffer结束数据帧 </p>
</li>
</ol>
<h2 id="Call格式">Call格式</h2><p>一个调用由请求消息、结果响应消息或者错误消息组成。请求和响应包含可扩展的元数据，两种消息都按照之前提出的方法分帧。</p>
<p>调用的请求格式为：</p>
<ol>
<li>请求元数据，一个类型值的映射。</li>
<li>消息名，一个Avro字符串。</li>
<li>消息参数。参数根据消息的请求定义序列化。</li>
</ol>
<p>调用的响应格式为：</p>
<ol>
<li>响应的元数据，一个类型值的映射。</li>
<li>一字节的错误标志位。</li>
<li>如果错误标志为false，响应消息，根据响应的模式序列化。如果错误标志位true，错误消息，根据消息的错误联合模式序列化。 </li>
</ol>
<h2 id="参考">参考</h2><ol>
<li><a href="http://avro.apache.org/docs/current/spec.html#Protocol+Wire+Format" target="_blank" rel="external">Apache Avro™ 1.7.7 Specification</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>Avro除了用于序列化外，还可以作为一种RPC框架来使用。客户端希望同服务器端交互时，就需要交换双方通信的协议，它类似于模式，需要双方来定义，在Avro中被称为消息(Message)。通信双方都必须保持这种协议，以便于解析从对方发送过来的数据，这也就是传说中的握手阶段。<br>]]>
    
    </summary>
    
      <category term="Avro" scheme="http://xfhnever.com/tags/Avro/"/>
    
      <category term="RPC" scheme="http://xfhnever.com/tags/RPC/"/>
    
      <category term="中间件" scheme="http://xfhnever.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="中间件" scheme="http://xfhnever.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Avro(三)-序列化和反序列化]]></title>
    <link href="http://xfhnever.com/2015/03/30/avro-serialization/"/>
    <id>http://xfhnever.com/2015/03/30/avro-serialization/</id>
    <published>2015-03-30T08:22:47.000Z</published>
    <updated>2015-10-01T12:40:03.000Z</updated>
    <content type="html"><![CDATA[<p>Avro是一个序列化的系统，所以本章我们介绍Avro的序列化和反序列化。<br><a id="more"></a><br>对Avro数据序列化/反序列化时都需要对模式以深度优先(Depth-First)，从左到右(Left-to-Right)的遍历顺序来执行。</p>
<p>Avro指定两种数据序列化编码方式：binary encoding 和Json encoding。使用二进制编码会高效序列化，并且序列化后得到的结果会比较小；而JSON一般用于调试系统或是基于WEB的应用。</p>
<h2 id="Binary_Encoding">Binary Encoding</h2><h3 id="基本数据类型">基本数据类型</h3><ol>
<li>null: Zero bytes</li>
<li>boolean: a single byte whose value is either 0 (false) or 1 (true).</li>
<li>int/long: variable-length zig-zag </li>
<li>float: 4 bytes</li>
<li>double: 8 bytes.</li>
<li>bytes: encoded as a long followed by that many bytes of data</li>
<li>string: encoded as a long followed by that many bytes of UTF-8 encoded character data </li>
</ol>
<h3 id="复杂数据类型">复杂数据类型</h3><ol>
<li>Records: encoded just the concatenation of the encodings of its fields</li>
<li>Enums: a int representing the zero-based position of the symbol in the schema</li>
<li>Arrays: encoded as series of blocks. A block with count 0 indicates the end of the array. block:{long,items}</li>
<li>Maps: encoded as series of blocks. A block with count 0 indicates the end of the map. block:{long,key/value pairs}.</li>
<li>Unions: encoded by first writing a long value indicating the zero-based position within the union of the schema of its value. The value is then encoded per the indicated schema within the union.</li>
<li>Fixed: encoded using number of bytes declared in the schema</li>
</ol>
<h4 id="实例">实例</h4><ol>
<li><p>String： “foo”</p>
<pre><code><span class="number">06</span> <span class="number">66</span> <span class="number">6f</span> <span class="number">6f</span>
</code></pre></li>
<li><p>records </p>
<pre><code>{
    "<span class="attribute">type</span>": <span class="value"><span class="string">"record"</span></span>, 
    "<span class="attribute">name</span>": <span class="value"><span class="string">"test"</span></span>,
    "<span class="attribute">fields</span>" : <span class="value">[
    {"<span class="attribute">name</span>": <span class="value"><span class="string">"a"</span></span>, "<span class="attribute">type</span>": <span class="value"><span class="string">"long"</span></span>},
    {"<span class="attribute">name</span>": <span class="value"><span class="string">"b"</span></span>, "<span class="attribute">type</span>": <span class="value"><span class="string">"string"</span></span>}
    ]
</span>}
</code></pre><p> 一个a=27,b=”foo”的实例：</p>
<pre><code><span class="number">36</span> <span class="number">06</span> <span class="number">66</span> <span class="number">6f</span> <span class="number">6f</span> 
</code></pre></li>
</ol>
<h2 id="JSON_Encoding">JSON Encoding</h2><p>Except for unions, the JSON encoding is the same as is used to encode field default values</p>
<h3 id="实例-1">实例</h3><p>the union schema [“null”,”string”,”Foo”]。</p>
<ol>
<li>null 编码为 null</li>
<li>string “a” 编码为{“string”: “a”}</li>
<li>Foo的实例编码为{“Foo”:{….}}</li>
</ol>
<h2 id="对象容器文件">对象容器文件</h2><p>Avro为了便于MapReduce的处理定义了一种容器文件格式(Container File Format)。这样的文件中只能有一种模式，所有需要存入这个文件的对象都需要按照这种模式以二进制编码的形式写入。对象在文件中以块(Block)来组织，并且这些对象都是可以被压缩的。块和块之间会存在同步标记符(Synchronization Marker)，以便MapReduce方便地切割文件用于处理。下图是根据文档描述画出的文件结构图：</p>
<img src="/images/post/avro3-1.jpg">
<p>一个存储文件由两部分组成:头信息(Header)和数据块(Data Block)。</p>
<p>头信息又由三部分构成：四个字节的前缀(类似于Magic Number)，文件Meta-data信息和随机生成的16字节同步标记符。</p>
<p>Avro目前支持的Meta-data有两种：schema和codec。codec表示对后面的文件数据块(File Data Block)采用何种压缩方式。Avro的实现都需要支持下面两种压缩方式：null(不压缩)和deflate(使用Deflate算法压缩数据块)。除了文档中认定的两种Meta-data，用户还可以自定义适用于自己的Meta-data。这里用long型来表示有多少个Meta-data数据对，也是让用户在实际应用中可以定义足够的Meta-data信息。对于每对Meta-data信息，都有一个string型的key(需要以“avro.” 为前缀)和二进制编码后的value。</p>
<p>对于文件中头信息之后的每个数据块，有这样的结构：一个long值记录当前块有多少个对象，一个long值用于记录当前块经过压缩后的字节数，真正的序列化对象和16字节长度的同步标记符。由于对象可以组织成不同的块，使用时就可以不经过反序列化而对某个数据块进行操作。还可以由数据块数，对象数和同步标记符来定位损坏的块以确保数据完整性。</p>
<h2 id="参考">参考</h2><ol>
<li><a href="http://avro.apache.org/docs/current/spec.html" target="_blank" rel="external">Apache Avro™ 1.7.7 Specification</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>Avro是一个序列化的系统，所以本章我们介绍Avro的序列化和反序列化。<br>]]>
    
    </summary>
    
      <category term="Avro" scheme="http://xfhnever.com/tags/Avro/"/>
    
      <category term="Serialization" scheme="http://xfhnever.com/tags/Serialization/"/>
    
      <category term="中间件" scheme="http://xfhnever.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="中间件" scheme="http://xfhnever.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Avro(二)-schema]]></title>
    <link href="http://xfhnever.com/2015/03/30/avro-schema/"/>
    <id>http://xfhnever.com/2015/03/30/avro-schema/</id>
    <published>2015-03-30T02:58:12.000Z</published>
    <updated>2015-10-01T15:19:15.000Z</updated>
    <content type="html"><![CDATA[<p>Avro依赖于模式(Schema)。通过模式定义各种数据结构，只有确定了模式才能对数据进行解释，所以在数据的序列化和反序列化之前，必须先确定模式的结构。正是模式的引入，使得数据具有了自描述的功能，同时能够实现动态加载，另外与其他的数据序列化系统如Thrift相比，数据之间不存在其他的任何标识，有利于提高数据处理的效率。下面我们就介绍一下Avro中的schema。<br><a id="more"></a></p>
<h2 id="schema定义">schema定义</h2><p>AVRO的Schema是用JSON的格式表示的，Schema可以用</p>
<ol>
<li>JSON String 来命名一个定义的类型</li>
<li><p>JSON 对象，形式如：</p>
<pre><code>{"<span class="attribute">type</span>": <span class="value"><span class="string">"typeName"</span> ...attributes...</span>}
</code></pre><p> typeName可以是一个原生类型或者下面将要定义的衍生类型。这篇文档没有定义JSON对象中的属性，这些属性可以成为meta data，但是不能影响序列化数据的格式。</p>
</li>
<li>JSON 数组，代表内嵌类型的并集（union）。</li>
</ol>
<h2 id="基本类型">基本类型</h2><p>总共8种原生类型 null,boolean,int,long,float,double,bytes,string.</p>
<ol>
<li>原生类型不需要attributes</li>
<li>可以通过type指定 “string” 和 ｛”type”:”string”｝是等同的</li>
</ol>
<h2 id="复杂类型">复杂类型</h2><p>总共6种复合类型 records,enums,arrays,maps,unions,fixed</p>
<h3 id="records">records</h3><p>records一般是序列化数据的最终展现单元，而且可以自己嵌套</p>
<pre><code><span class="collection">{
  <span class="string">"type"</span>: <span class="string">"record"</span>, 
  <span class="string">"name"</span>: <span class="string">"LongList"</span>,
  <span class="string">"aliases"</span>: <span class="collection">[<span class="string">"LinkedLongs"</span>]</span>,                      // old name for this
  <span class="string">"fields"</span> : <span class="collection">[
    <span class="collection">{<span class="string">"name"</span>: <span class="string">"value"</span>, <span class="string">"type"</span>: <span class="string">"long"</span>}</span>,             // each element has a long
    <span class="collection">{<span class="string">"name"</span>: <span class="string">"next"</span>, <span class="string">"type"</span>: <span class="collection">[<span class="string">"null"</span>, <span class="string">"LongList"</span>]</span>}</span> // optional next element
  ]</span>
}</span>
</code></pre><h3 id="enums">enums</h3><pre><code>{ "<span class="attribute">type</span>": <span class="value"><span class="string">"enum"</span></span>,
  "<span class="attribute">name</span>": <span class="value"><span class="string">"Suit"</span></span>,
  "<span class="attribute">symbols</span>" : <span class="value">[<span class="string">"SPADES"</span>, <span class="string">"HEARTS"</span>, <span class="string">"DIAMONDS"</span>, <span class="string">"CLUBS"</span>]
</span>}
</code></pre><h3 id="arrays">arrays</h3><pre><code>{"<span class="attribute">type</span>": <span class="value"><span class="string">"array"</span></span>, "<span class="attribute">items</span>": <span class="value"><span class="string">"string"</span></span>}
</code></pre><h3 id="Maps">Maps</h3><p>keys必须是string，所以这里只指定了values的类型</p>
<pre><code>{"<span class="attribute">type</span>": <span class="value"><span class="string">"map"</span></span>, "<span class="attribute">values</span>": <span class="value"><span class="string">"long"</span></span>}
</code></pre><h3 id="Unions">Unions</h3><p>不能包含两个或者两个以上没有name属性的相同类型</p>
<pre><code>[<span class="string">"string"</span>, <span class="string">"null"</span>]
</code></pre><h3 id="Fixed">Fixed</h3><p>size指定每个值占用多少个字节</p>
<pre><code>{"<span class="attribute">type</span>": <span class="value"><span class="string">"fixed"</span></span>, "<span class="attribute">size</span>": <span class="value"><span class="number">16</span></span>, "<span class="attribute">name</span>": <span class="value"><span class="string">"md5"</span></span>}
</code></pre><h2 id="schema兼容">schema兼容</h2><p>因为应用版本的问题经常遇到读和写的schema不相同的情况，幸运的是avro已经提供了相关的解决方案：</p>
<img src="/images/post/avro2-1.jpg">    
<h3 id="record兼容">record兼容</h3><p>实际应用中，更多是以record的形式进行交互，接下来我们重点讲解下record的兼容。</p>
<h3 id="读写schema的角度">读写schema的角度</h3><p>从读写schema的角度考虑，读写schema的不同无外乎就两种，读的schema比写的schema多了一个field，读的schema比写的schema少了一个field，这两种情况处理起来都很简单。</p>
<ol>
<li>增加了field的情况:增加的fields用默认值空字符串代替；</li>
<li>减少了field的情况:删除的field被忽略掉</li>
</ol>
<h3 id="新旧版本schema">新旧版本schema</h3><ol>
<li><p>新版本schema比旧版本schema增加了一个字段</p>
<p> 新版本读旧版本的数据，使用新版本schema里新增field的默认值</p>
<p> 旧版本读新版本的数据，新版本schema里新增field被旧版本的忽略掉    </p>
</li>
<li><p>新版本schema比旧版本schema少了一个字段</p>
<p> 新版本读旧版本的数据，减少的field被新版本忽略掉</p>
<p> 旧版本读新版本的数据，旧版本的schema使用被删除field的默认值，如果没有就会报错，那么升级旧版本</p>
</li>
</ol>
<h3 id="别名">别名</h3><p>别名是另一个用于schema兼容的方法，可以将写的schema的field名字转换成读的schema的field，记住并不是加了aliases字段。而是将写的filed的name属性变为aliases，读的时候只认name属性。</p>
<h2 id="参考">参考</h2><ol>
<li><a href="http://avro.apache.org/docs/current/spec.html" target="_blank" rel="external">Apache Avro™ 1.7.7 Specification</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>Avro依赖于模式(Schema)。通过模式定义各种数据结构，只有确定了模式才能对数据进行解释，所以在数据的序列化和反序列化之前，必须先确定模式的结构。正是模式的引入，使得数据具有了自描述的功能，同时能够实现动态加载，另外与其他的数据序列化系统如Thrift相比，数据之间不存在其他的任何标识，有利于提高数据处理的效率。下面我们就介绍一下Avro中的schema。<br>]]>
    
    </summary>
    
      <category term="Avro" scheme="http://xfhnever.com/tags/Avro/"/>
    
      <category term="Schema" scheme="http://xfhnever.com/tags/Schema/"/>
    
      <category term="中间件" scheme="http://xfhnever.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="中间件" scheme="http://xfhnever.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Avro(一)-介绍]]></title>
    <link href="http://xfhnever.com/2015/03/29/avro-intro/"/>
    <id>http://xfhnever.com/2015/03/29/avro-intro/</id>
    <published>2015-03-29T10:12:57.000Z</published>
    <updated>2015-10-01T15:19:58.000Z</updated>
    <content type="html"><![CDATA[<p>Avro是Hadoop中的一个子项目，也是Apache中一个独立的项目，Avro是一个基于二进制数据传输高性能的中间件。在Hadoop的其他项目中例如HBase(Ref)和Hive(Ref)的Client端与服务端的数据传输也采用了这个工具。Avro是一个数据序列化的系统。Avro 可以将数据结构或对象转化成便于存储或传输的格式。Avro设计之初就用来支持数据密集型应用，适合于远程或本地大规模数据的存储和交换。<br><a id="more"></a></p>
<h2 id="特点">特点</h2><ol>
<li>丰富的数据结构类型；</li>
<li>快速可压缩的二进制数据形式，对数据二进制序列化后可以节约数据存储空间和网络传输带宽；</li>
<li>存储持久数据的文件容器；</li>
<li>可以实现远程过程调用RPC；</li>
<li>简单的动态语言结合功能，Avro和动态语言结合后，读写数据文件和使用RPC协议都不需要生成代码，而代码生成作为一种可选的优化只值得在静态类型语言中实现。</li>
</ol>
<h2 id="横向对比">横向对比</h2><p>同类软件还有：</p>
<ol>
<li>thrift：由 Facebook 主导开发的 , 一个跨平台，支持多语言的，通过定义 IDL 文件，自动生成 RPC 客户端与服务端通信代码的工具，以构建在多种编程语言间无缝结合的、高效的服务</li>
<li>protocol buffer：一种序列化与结构化数据的一种机制，具有跨平台、解析速度快、序列化数据体积小、扩展性高、使用简单的特点</li>
</ol>
<h3 id="thrift和avro对比">thrift和avro对比</h3><h3 id="Schema处理">Schema处理</h3><ol>
<li>thrift依赖IDL–&gt;代码的生成，静态的。走代码生成，编译载入的流程。 </li>
<li>Avro可以生成代码，后编译执行，但是还必须依赖IDL（meta元数据描述）；也可以走动态解释执行IDL序列化的方式</li>
</ol>
<h3 id="序列化的方式">序列化的方式</h3><ol>
<li><p>thrift</p>
<p> 提供多种序列化实现，TCompactProtocol，TBinaryProtocol</p>
<p> 每个Field前面都是带Tag的，这个Tag用于标识这个域的类型和顺序ID（IDL中定义，用于Versioning）。在同一批数据里面，这些Tag的信息是完全相同的，当数据条数大的时候这显然就浪费了。</p>
 <img src="/images/post/avro1-1.jpg"></li>
<li><p>Acro</p>
<p> 格式包括:文件头中有schema+数据records(自描述)</p>
 <img src="/images/post/avro1-2.jpg">
<p> 只对感兴趣的部分反序列化</p>
<p> schema允许定义数据的排序order</p>
<p> 采用block链表结构，突破了用单一整型表示大小的限制。比如Array或Map由一系列Block组成，每个Block包含计数器和对应的元    素，计数器为0标识结束。</p>
</li>
</ol>
<h3 id="RPC的服务">RPC的服务</h3><ol>
<li><p>Thrift</p>
<p> TThreadPolServer: 多线程服务</p>
<p> TNonBlockingServer: 单线程 non blocking的服务</p>
<p> THsHaServer: 多线程 non blocking的服务</p>
</li>
<li><p>Avro</p>
<p> HttpServer : 缺省,基于Jetty内核的服务.</p>
<p> NettyServer: 新的基于Netty的服务.</p>
</li>
</ol>
<h3 id="总结">总结</h3><ol>
<li>Thrift适用于程序对程序静态的数据交换，要求schema预知并相对固定</li>
<li>Avro在Thrift基础上增加了对schema动态的支持且性能上不输于Thrift</li>
<li>Avro显式schema设计使它更适用于搭建数据交换及存储的通用工具和平台,特别是在后台</li>
<li>目前Thrift的优势在于更多的语言支持和相对成熟</li>
<li>PB具有跨平台、解析速度快、序列化数据体积小、扩展性高、使用简单的特点，但是内嵌并没有提供RPC的通讯</li>
</ol>
<p>Avro的创新之处在于融合了显式,declarative的Schema和高效二进制的数据表达，强调数据的自我描述，克服了以往单纯XML或二进制系统的缺陷。Avro对Schema动态加载功能，是Thrift编程接口所不具备的，符合了Hadoop上的Hive/Pig及NOSQL 等既属于ad hoc，又追求性能的应用需求.</p>
<h3 id="官网给出的对比">官网给出的对比</h3><ol>
<li>动态类型：Avro并不需要生成代码，模式和数据存放在一起，而模式使得整个数据的处理过程并不生成代码、静态数据类型等等。这方便了数据处理系统和语言的构造。</li>
<li>未标记的数据：由于读取数据的时候模式是已知的，那么需要和数据一起编码的类型信息就很少了，这样序列化的规模也就小了。</li>
<li>不需要用户指定字段号：即使模式改变，处理数据时新旧模式都是已知的，所以通过使用字段名称可以解决差异问题。</li>
</ol>
<h3 id="为何不使用java序列化">为何不使用java序列化</h3><ol>
<li>java序列化不够灵活，不能更好的控制序列化的整个流程</li>
<li>java序列化不符合序列化的标准，没有做一定的压缩，java序列化首先写类名，然后再是整个类的数据，而且成员对象在序列化中只存引用，成员对象的可以出现的位置很随机，既可以在序列化的对象前，也可以在其后面，这样就对随机访问造成影响，一旦出错，整个后面的序列化就会全部错误</li>
<li>Java序列化每次序列化都要重新创建对象，内存消耗大。</li>
</ol>
<h2 id="实例">实例</h2><p>因为目前我们使用Avro主要是用来进行序列化，所以下面给出的实例也是对Avro序列化功能的展示。</p>
<p>首先定义一个schema: user.avsc：</p>
<pre><code>{"<span class="attribute">namespace</span>": <span class="value"><span class="string">"example.avro"</span></span>,
 "<span class="attribute">type</span>": <span class="value"><span class="string">"record"</span></span>,
 "<span class="attribute">name</span>": <span class="value"><span class="string">"User"</span></span>,
 "<span class="attribute">fields</span>": <span class="value">[
     {"<span class="attribute">name</span>": <span class="value"><span class="string">"name"</span></span>, "<span class="attribute">type</span>": <span class="value"><span class="string">"string"</span></span>},
     {"<span class="attribute">name</span>": <span class="value"><span class="string">"favorite_number"</span></span>,  "<span class="attribute">type</span>": <span class="value">[<span class="string">"int"</span>, <span class="string">"null"</span>]</span>},
     {"<span class="attribute">name</span>": <span class="value"><span class="string">"favorite_color"</span></span>, "<span class="attribute">type</span>": <span class="value">[<span class="string">"string"</span>, <span class="string">"null"</span>]</span>}
 ]
</span>}
</code></pre><p>使用Avro进行序列化和反序列化有两种不同的途径：代码生成和不走代码生成。</p>
<h3 id="代码生成">代码生成</h3><p>首先使用schema生成Java类： User.class。</p>
<ol>
<li><p>创建User</p>
<pre><code>User user1 = <span class="keyword">new</span> User();
user1.setName(<span class="string">"Alyssa"</span>);
user1.setFavoriteNumber(<span class="number">256</span>);
<span class="comment">// Leave favorite color null</span>

<span class="comment">// Alternate constructor</span>
User user2 = <span class="keyword">new</span> User(<span class="string">"Ben"</span>, <span class="number">7</span>, <span class="string">"red"</span>);

<span class="comment">// Construct via builder</span>
User user3 = User.newBuilder()
             .setName(<span class="string">"Charlie"</span>)
             .setFavoriteColor(<span class="string">"blue"</span>)
             .setFavoriteNumber(null)
             .build();
</code></pre></li>
<li><p>序列化</p>
<pre><code><span class="comment">// Serialize user1, user2 and user3 to disk</span>
DatumWriter&lt;User&gt; userDatumWriter = <span class="keyword">new</span> SpecificDatumWriter&lt;User&gt;(User.<span class="keyword">class</span>);
DataFileWriter&lt;User&gt; dataFileWriter = <span class="keyword">new</span> DataFileWriter&lt;User&gt;(userDatumWriter);
dataFileWriter.create(user1.getSchema(), <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">"users.avro"</span>));
dataFileWriter.<span class="keyword">append</span>(user1);
dataFileWriter.<span class="keyword">append</span>(user2);
dataFileWriter.<span class="keyword">append</span>(user3);
dataFileWriter.close();
</code></pre></li>
<li><p>反序列化</p>
<pre><code>// Deserialize Users <span class="keyword">from</span> disk
DatumReader<span class="variable">&lt;User&gt;</span> <span class="keyword">user</span>DatumReader = new SpecificDatumReader<span class="variable">&lt;User&gt;</span>(User.class);
DataFileReader<span class="variable">&lt;User&gt;</span> dataFileReader = new DataFileReader<span class="variable">&lt;User&gt;</span>(file, <span class="keyword">user</span>DatumReader);
User <span class="keyword">user</span> = null;
while (dataFileReader.hasNext()) {
// Reuse <span class="keyword">user</span> object by passing it <span class="keyword">to</span> next(). This saves us <span class="keyword">from</span>
// allocating and garbage collecting many objects <span class="keyword">for</span> files with
// many items.
<span class="keyword">user</span> = dataFileReader.next(<span class="keyword">user</span>);
System.<span class="keyword">out</span>.println(<span class="keyword">user</span>);
}
</code></pre></li>
</ol>
<h3 id="直接使用schema">直接使用schema</h3><ol>
<li><p>创建User</p>
<pre><code>Schema schema = <span class="keyword">new</span> Schema.Parser().parse(<span class="keyword">new</span> File(<span class="string">"user.avsc"</span>));
GenericRecord user1 = <span class="keyword">new</span> GenericData.Record(schema);
user1.<span class="keyword">put</span>(<span class="string">"name"</span>, <span class="string">"Alyssa"</span>);
user1.<span class="keyword">put</span>(<span class="string">"favorite_number"</span>, <span class="number">256</span>);
// Leave favorite color null

GenericRecord user2 = <span class="keyword">new</span> GenericData.Record(schema);
user2.<span class="keyword">put</span>(<span class="string">"name"</span>, <span class="string">"Ben"</span>);
user2.<span class="keyword">put</span>(<span class="string">"favorite_number"</span>, <span class="number">7</span>);
user2.<span class="keyword">put</span>(<span class="string">"favorite_color"</span>, <span class="string">"red"</span>);
</code></pre></li>
<li><p>序列化</p>
<pre><code><span class="comment">// Serialize user1 and user2 to disk</span>
<span class="keyword">File</span> <span class="keyword">file</span> = <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">"users.avro"</span>);
DatumWriter&lt;GenericRecord&gt; datumWriter = <span class="keyword">new</span> GenericDatumWriter&lt;GenericRecord&gt;(schema);
DataFileWriter&lt;GenericRecord&gt; dataFileWriter = <span class="keyword">new</span> DataFileWriter&lt;GenericRecord&gt;(datumWriter);
dataFileWriter.create(schema, <span class="keyword">file</span>);
dataFileWriter.<span class="keyword">append</span>(user1);
dataFileWriter.<span class="keyword">append</span>(user2);
dataFileWriter.close();
</code></pre></li>
<li><p>反序列化</p>
<pre><code>// Deserialize users <span class="keyword">from</span> disk
DatumReader<span class="variable">&lt;GenericRecord&gt;</span> datumReader = new GenericDatumReader<span class="variable">&lt;GenericRecord&gt;</span>(schema);
DataFileReader<span class="variable">&lt;GenericRecord&gt;</span> dataFileReader = new DataFileReader<span class="variable">&lt;GenericRecord&gt;</span>(file, datumReader);
GenericRecord <span class="keyword">user</span> = null;
while (dataFileReader.hasNext()) {
// Reuse <span class="keyword">user</span> object by passing it <span class="keyword">to</span> next(). This saves us <span class="keyword">from</span>
// allocating and garbage collecting many objects <span class="keyword">for</span> files with
// many items.
<span class="keyword">user</span> = dataFileReader.next(<span class="keyword">user</span>);
System.<span class="keyword">out</span>.println(<span class="keyword">user</span>);
</code></pre></li>
</ol>
<h2 id="参考">参考</h2><ol>
<li><a href="http://avro.apache.org/docs/current/index.html" target="_blank" rel="external">Apache Avro™ 1.7.7 Documentation</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>Avro是Hadoop中的一个子项目，也是Apache中一个独立的项目，Avro是一个基于二进制数据传输高性能的中间件。在Hadoop的其他项目中例如HBase(Ref)和Hive(Ref)的Client端与服务端的数据传输也采用了这个工具。Avro是一个数据序列化的系统。Avro 可以将数据结构或对象转化成便于存储或传输的格式。Avro设计之初就用来支持数据密集型应用，适合于远程或本地大规模数据的存储和交换。<br>]]>
    
    </summary>
    
      <category term="Avro" scheme="http://xfhnever.com/tags/Avro/"/>
    
      <category term="中间件" scheme="http://xfhnever.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="中间件" scheme="http://xfhnever.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Dropwizard(二)-配置文件]]></title>
    <link href="http://xfhnever.com/2015/03/28/dropwizard-configuration/"/>
    <id>http://xfhnever.com/2015/03/28/dropwizard-configuration/</id>
    <published>2015-03-28T15:01:28.000Z</published>
    <updated>2015-10-01T15:21:59.000Z</updated>
    <content type="html"><![CDATA[<p>Dropwizard每一个Application子类都有一个类型参数，也就是Configuration子类。当我们的应用运行server配置命令时，Dropwizard会解析YAML配置文件，然后通过映射来创建一个Configuration的实例。<br><a id="more"></a><br>YAML配置一般存在于项目中的.yml活着.yaml文件中，一个配置文件实例如下：</p>
<pre><code><span class="attribute">template</span>: <span class="string">Hello, %s!</span>

<span class="http"><span class="attribute">defaultName</span>: <span class="string">${DW_DEFAULT_NAME:-Stranger}</span>

<span class="bash"><span class="comment"># Database settings.</span>
database:

  <span class="comment"># the name of your JDBC driver</span>
  driverClass: org.h2.Driver

  <span class="comment"># the username</span>
  user: sa

  <span class="comment"># the password</span>
  password: sa

  <span class="comment"># the JDBC URL</span>
  url: jdbc:h2:./target/example

<span class="comment"># use the simple server factory if you only want to run on a single port</span>
<span class="comment">#server:</span>
<span class="comment">#  type: simple</span>
<span class="comment">#  connector:</span>
<span class="comment">#    type: http</span>
<span class="comment">#    port: 8080</span>

server:
<span class="comment">#  softNofileLimit: 1000</span>
<span class="comment">#  hardNofileLimit: 1000</span>
  applicationConnectors:
    - <span class="built_in">type</span>: http
      port: <span class="number">8080</span>
    - <span class="built_in">type</span>: https
      port: <span class="number">8443</span>
      keyStorePath: example.keystore
      keyStorePassword: example
      validateCerts: <span class="literal">false</span>
<span class="comment"># this requires the alpn-boot library on the JVM's boot classpath</span>
<span class="comment">#    - type: spdy3</span>
<span class="comment">#      port: 8445</span>
<span class="comment">#      keyStorePath: example.keystore</span>
<span class="comment">#      keyStorePassword: example</span>
<span class="comment">#      validateCerts: false</span>
  adminConnectors:
    - <span class="built_in">type</span>: http
      port: <span class="number">8081</span>
    - <span class="built_in">type</span>: https
      port: <span class="number">8444</span>
      keyStorePath: example.keystore
      keyStorePassword: example
      validateCerts: <span class="literal">false</span>

<span class="comment"># Logging settings.</span>
logging:

  <span class="comment"># The default level of all loggers. Can be OFF, ERROR, WARN, INFO, DEBUG, TRACE, or ALL.</span>
  level: INFO

  <span class="comment"># Logger-specific levels.</span>
  loggers:

    <span class="comment"># Sets the level for 'com.example.app' to DEBUG.</span>
    com.example.app: DEBUG

    org.hibernate.SQL: ALL

  appenders:
    - <span class="built_in">type</span>: console
    - <span class="built_in">type</span>: file
      threshold: DEBUG
      <span class="built_in">log</span>Format: <span class="string">"%-6level [%d{HH:mm:ss.SSS}] [%t] %logger{5} - %X{code} %msg %n"</span>
      currentLogFilename: /tmp/application.log
      archivedLogFilenamePattern: /tmp/application-%d{yyyy-MM-dd}.log
      archivedFileCount: <span class="number">7</span>
      timeZone: UTC

<span class="comment"># the key needs to match the suffix of the renderer</span>
viewRendererConfiguration:
    .ftl:
        strict_syntax: yes
        whitespace_stripping: yes</span></span>
</code></pre><p>下面我们就介绍一下其中我们项目中经常使用到的配置参数。</p>
<h2 id="Logging">Logging</h2><p>Dropwizard使用Logback记录日志，同时提供了slf4j的实现，甚至通过Logback可以使用所有的java.util.logging, Log4j, and Apache Commons Logging。</p>
<h3 id="Log_Format">Log Format</h3><pre><code>TRACE [<span class="number">2010</span>-<span class="number">04</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">42</span>:<span class="number">35</span>,<span class="number">271</span>] com.example.dw.Thing: Contemplating doing a thing.
DEBUG [<span class="number">2010</span>-<span class="number">04</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">42</span>:<span class="number">35</span>,<span class="number">274</span>] com.example.dw.Thing: About to <span class="keyword">do</span> a thing.
</code></pre><p>可以通过tail和grep命令过滤Log，例如：</p>
<pre><code>tail -f dw.<span class="keyword">log</span> | <span class="keyword">grep</span> <span class="string">'^WARN'</span>
</code></pre><h3 id="Configuration">Configuration</h3><p>可以在YAML配置文件中进行配置</p>
<h2 id="Logging_settings-">Logging settings.</h2><pre><code>logging:

  # The <span class="keyword">default</span> level <span class="keyword">of</span> <span class="keyword">all</span> loggers. Can be OFF, ERROR, WARN, INFO, DEBUG, TRACE, <span class="keyword">or</span> <span class="keyword">ALL</span>.
  level: INFO

  # Logger-specific levels.
  loggers:

    # Overrides the level <span class="keyword">of</span> com.example.dw.Thing <span class="keyword">and</span> sets it <span class="keyword">to</span> DEBUG.
    <span class="string">"com.example.dw.Thing"</span>: DEBUG
</code></pre><h3 id="Console_Logging">Console Logging</h3><p>By default, Dropwizard applications log INFO and higher to STDOUT。</p>
<p>日志可以输出到控制台：</p>
<pre><code><span class="attribute">logging</span>:
  <span class="attribute">appenders</span>:
    - <span class="attribute">type</span>: console
      <span class="attribute">threshold</span>: WARN
      <span class="attribute">target</span>: stderr
</code></pre><h3 id="File_Logging">File Logging</h3><p>也可以输出到文件中：</p>
<pre><code>logging:

  appenders:
    - <span class="keyword">type</span>: <span class="keyword">file</span>
      # The <span class="keyword">file</span> to <span class="keyword">which</span> current statements will be logged.
      currentLogFilename: ./logs/example.<span class="literal">log</span>

      # When the <span class="keyword">log</span> <span class="keyword">file</span> rotates, the archived <span class="keyword">log</span> will be renamed to this and gzipped. The
      # %<span class="keyword">d</span> is replaced with the previous day (yyyy-MM-dd). Custom <span class="keyword">rolling</span> windows can be created
      # <span class="keyword">by</span> passing a SimpleDateFormat-compatible <span class="keyword">format</span> <span class="keyword">as</span> <span class="keyword">an</span> argument: <span class="string">"%d{yyyy-MM-dd-hh}"</span>.
      archivedLogFilenamePattern: ./logs/example-%<span class="keyword">d</span>.<span class="keyword">log</span>.gz

      # The number of archived files to <span class="keyword">keep</span>.
      archivedFileCount: 5

      # The timezone used to <span class="keyword">format</span> dates. HINT: <span class="keyword">USE</span> THE DEFAULT, UTC.
      timeZone: UTC
</code></pre><h3 id="Syslog_Logging">Syslog Logging</h3><p>Dropwizard can also log statements to syslog：</p>
<pre><code>logging:

  appenders:
    - <span class="built_in">type</span>: syslog
      <span class="comment"># The hostname of the syslog server to which statements will be sent.</span>
      <span class="comment"># N.B.: If this is the local host, the local syslog instance will need to be configured to</span>
      <span class="comment"># listen on an inet socket, not just a Unix socket.</span>
      host: localhost

      <span class="comment"># The syslog facility to which statements will be sent.</span>
      facility: <span class="built_in">local</span>0
</code></pre><h3 id="参数介绍">参数介绍</h3><ol>
<li>Level: Logback输出级别</li>
<li>loggers: 特定日志配置</li>
<li>appenders: 输出目标配置，可以组合多个。</li>
</ol>
<h2 id="Server">Server</h2><p>参考最初给出的配置文件例子，我们主要介绍下面几个配置参数：</p>
<h3 id="applicationConnectors">applicationConnectors</h3><p>处理应用请求的connectors集合。</p>
<h3 id="adminConnectors">adminConnectors</h3><p>处理admin请求的connectors 集合。例如：</p>
<ol>
<li>POST <a href="http://dw.example.com:8081/tasks/gc" target="_blank" rel="external">http://dw.example.com:8081/tasks/gc</a></li>
<li>GET <a href="http://dw.example.com:8081/threads" target="_blank" rel="external">http://dw.example.com:8081/threads</a></li>
<li>GET <a href="http://dw.example.com:8081/healthcheck" target="_blank" rel="external">http://dw.example.com:8081/healthcheck</a> </li>
</ol>
<h2 id="参考">参考</h2><ol>
<li><a href="https://dropwizard.github.io/dropwizard/manual/core.html" target="_blank" rel="external">Dropwizard Core</a></li>
<li><a href="https://dropwizard.github.io/dropwizard/manual/configuration.html" target="_blank" rel="external">Dropwizard Configuration Reference</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>Dropwizard每一个Application子类都有一个类型参数，也就是Configuration子类。当我们的应用运行server配置命令时，Dropwizard会解析YAML配置文件，然后通过映射来创建一个Configuration的实例。<br>]]>
    
    </summary>
    
      <category term="Dropwizard" scheme="http://xfhnever.com/tags/Dropwizard/"/>
    
      <category term="Framework" scheme="http://xfhnever.com/tags/Framework/"/>
    
      <category term="REST" scheme="http://xfhnever.com/tags/REST/"/>
    
      <category term="ttpod" scheme="http://xfhnever.com/tags/ttpod/"/>
    
      <category term="Framework" scheme="http://xfhnever.com/categories/Framework/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Dropwizard(一)-介绍]]></title>
    <link href="http://xfhnever.com/2015/03/28/dropwizard-intro/"/>
    <id>http://xfhnever.com/2015/03/28/dropwizard-intro/</id>
    <published>2015-03-28T12:23:58.000Z</published>
    <updated>2015-10-01T15:21:11.000Z</updated>
    <content type="html"><![CDATA[<p>Dropwizard 是一个开源的Java框架，用于开发OPS友好、高性能的基于REST的后端。它是由Yammer开发的，来驱动基于JVM的后端。目前公司的Rest服务都是基于这个开发的。<br><a id="more"></a></p>
<h2 id="包含类库">包含类库</h2><p>Dropwizard集成了Java生态系统中各个问题域中最优秀的组件，帮助开发者快速的打造一个Rest风格的后台服务。包含：</p>
<ol>
<li>Jetty for HTTP: 每一个应用程序被打包成一个jar（而不是war）文件，并开始自己的嵌入式Jetty容器。没有任何war文件和外部servlet容器。</li>
<li>Jersey for REST: Jersey（JAX-RS的参考实现）是用来写基于REST的Web服务的。</li>
<li>Jackson for JSON: 用来做所有的JSON处理。</li>
<li>Metrics for metrics: 支持监控使用标准库，它在监控代码方面有无与伦比的洞察力。</li>
<li>Log: 使用Logback和SLF4J完成 </li>
<li>Hibernate Validator: 使用Hibernate验证API进行声明性验证。</li>
<li>Guava: …….</li>
</ol>
<h2 id="优点">优点</h2><ol>
<li>和Maven,Gradle集成良好</li>
<li>轻量级，开发迅速，部署简单； </li>
<li>代码结构好，可读性高； </li>
<li>自动为服务提供OM框架； </li>
<li>Resource概念让开发者自然的把一个应用拆分为一个个的小服务 </li>
</ol>
<h3 id="与spring_boot的对比">与spring boot的对比</h3><img src="/images/post/dropwizard1-1.png">
<h3 id="Spring的依赖">Spring的依赖</h3><p>Spring Boot聚焦于Spring应用，如果你希望进入Spring生态环境，或者已经熟悉它，希望有一个快速起步，那么选择它是好的选择，而DropWizard是将其REST和Jersey结合在一起，它帮助你离开对Spring的依赖。</p>
<h3 id="Http服务器">Http服务器</h3><p>这里我们看到Spring Boot更加灵活，Dropwizard以约定优于配置，比Spring Boot更极端点，完全是基于Jetty，而Spring Boot默认使用嵌入的Tomcat，其他也可以选择。</p>
<h3 id="日志">日志</h3><p>Dropwizard 从log4j切换到LogBack，而Spring boot提供 Logback, log4j 和 log4j2选择，LogBack是一个更好的Log4j，性能要比log4j提高，不过要注意不同的方法使用性能不同。</p>
<h3 id="依赖注入">依赖注入</h3><p>两个框架主要区别是依赖注入的不同，Spring核心有依赖注入，而DropWizard需要你选择，这也带来了灵活性，有Google Guice或更新更好的依赖注入框架可供选择。</p>
<h3 id="测试">测试</h3><p>两个框架都有 dropwizard-testing 和 spring-boot-starter-test支持。</p>
<p>两者都有很强很大的社区支持。如果你更喜欢轻量，无疑Dropwizard胜出，如果你已经有Spring经验，无疑使用Spring Boot。</p>
<h2 id="代码实例">代码实例</h2><h3 id="Creating_A_Configuration_Class">Creating A Configuration Class</h3><pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldConfiguration</span> <span class="keyword">extends</span> <span class="title">Configuration</span> </span>{
    <span class="annotation">@NotEmpty</span>
    <span class="keyword">private</span> String template;
    <span class="annotation">@NotEmpty</span>
    <span class="keyword">private</span> String defaultName = <span class="string">"Stranger"</span>;

    <span class="annotation">@JsonProperty</span>
    <span class="function"><span class="keyword">public</span> String <span class="title">getTemplate</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> template;
    }
    <span class="annotation">@JsonProperty</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTemplate</span><span class="params">(String template)</span> </span>{
        <span class="keyword">this</span>.template = template;
    }

    <span class="annotation">@JsonProperty</span>
    <span class="function"><span class="keyword">public</span> String <span class="title">getDefaultName</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> defaultName;
    }
    <span class="annotation">@JsonProperty</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultName</span><span class="params">(String name)</span> </span>{
        <span class="keyword">this</span>.defaultName = name;
    }
}
</code></pre><p>其中YAML配置文件hello-world.yml对应内容如下：</p>
<pre><code><span class="attribute">template</span>: <span class="string">Hello, %s!</span>
<span class="attribute">defaultName</span>: <span class="string">Stranger</span>
</code></pre><h3 id="Creating_An_Application_Class">Creating An Application Class</h3><pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldApplication</span> <span class="keyword">extends</span> <span class="title">Application</span>&lt;<span class="title">HelloWorldConfiguration</span>&gt; </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{
        <span class="keyword">new</span> HelloWorldApplication().run(args);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="string">"hello-world"</span>;
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(Bootstrap&lt;HelloWorldConfiguration&gt; bootstrap)</span> </span>{
        <span class="comment">// nothing to do yet</span>
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(HelloWorldConfiguration configuration,
                    Environment environment)</span> </span>{
        <span class="comment">// nothing to do yet</span>
    }

}
</code></pre><h3 id="Creating_A_Representation_Class">Creating A Representation Class</h3><pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Saying</span> </span>{
    <span class="keyword">private</span> <span class="keyword">long</span> id;

    <span class="annotation">@Length</span>(max = <span class="number">3</span>)
    <span class="keyword">private</span> String content;

    <span class="function"><span class="keyword">public</span> <span class="title">Saying</span><span class="params">()</span> </span>{
        <span class="comment">// Jackson deserialization</span>
    }

    <span class="function"><span class="keyword">public</span> <span class="title">Saying</span><span class="params">(<span class="keyword">long</span> id, String content)</span> </span>{
        <span class="keyword">this</span>.id = id;
        <span class="keyword">this</span>.content = content;
    }

    <span class="annotation">@JsonProperty</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> id;
    }

    <span class="annotation">@JsonProperty</span>
    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> content;
    }
}
</code></pre><h3 id="Creating_A_Resource_Class">Creating A Resource Class</h3><pre><code><span class="keyword">@Path</span>(<span class="string">"/hello-world"</span>)
<span class="keyword">@Produces</span>(MediaType.APPLICATION_JSON)
<span class="keyword">public</span> <span class="keyword">class</span> HelloWorldResource {
    <span class="keyword">private</span> <span class="keyword">final</span> String <span class="keyword">template</span>;
    <span class="keyword">private</span> <span class="keyword">final</span> String defaultName;
    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong counter;

    <span class="keyword">public</span> HelloWorldResource(String <span class="keyword">template</span>, String defaultName) {
        <span class="keyword">this</span>.<span class="keyword">template</span> = <span class="keyword">template</span>;
        <span class="keyword">this</span>.defaultName = defaultName;
        <span class="keyword">this</span>.counter = <span class="keyword">new</span> AtomicLong();
    }

    <span class="keyword">@GET</span>
    <span class="keyword">@Timed</span>
    <span class="keyword">public</span> Saying sayHello(<span class="keyword">@QueryParam</span>(<span class="string">"name"</span>) Optional&lt;String&gt; name) {
        <span class="keyword">final</span> String value = String.format(<span class="keyword">template</span>, name.or(defaultName));
        <span class="keyword">return</span> <span class="keyword">new</span> Saying(counter.incrementAndGet(), value);
    }
}
</code></pre><h3 id="Registering_A_Resource">Registering A Resource</h3><pre><code><span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(HelloWorldConfiguration configuration,
                Environment environment)</span> </span>{
    <span class="keyword">final</span> HelloWorldResource resource = <span class="keyword">new</span> HelloWorldResource(
        configuration.getTemplate(),
        configuration.getDefaultName()
    );
    environment.jersey().register(resource);
}
</code></pre><h3 id="Creating_A_Health_Check">Creating A Health Check</h3><pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">TemplateHealthCheck</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">HealthCheck</span> {</span>
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> template;

    public <span class="type">TemplateHealthCheck</span>(<span class="type">String</span> template) {
        <span class="keyword">this</span>.template = template;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> <span class="type">Result</span> check() <span class="keyword">throws</span> <span class="type">Exception</span> {
        <span class="keyword">final</span> <span class="type">String</span> saying = <span class="type">String</span>.format(template, <span class="string">"TEST"</span>);
        <span class="keyword">if</span> (!saying.contains(<span class="string">"TEST"</span>)) {
            <span class="keyword">return</span> <span class="type">Result</span>.unhealthy(<span class="string">"template doesn't include a name"</span>);
        }
        <span class="keyword">return</span> <span class="type">Result</span>.healthy();
    }
}
</code></pre><h3 id="Adding_A_Health_Check">Adding A Health Check</h3><pre><code><span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(HelloWorldConfiguration configuration,
                Environment environment)</span> </span>{
    <span class="keyword">final</span> HelloWorldResource resource = <span class="keyword">new</span> HelloWorldResource(
        configuration.getTemplate(),
        configuration.getDefaultName()
    );
    <span class="keyword">final</span> TemplateHealthCheck healthCheck =
        <span class="keyword">new</span> TemplateHealthCheck(configuration.getTemplate());
    environment.healthChecks().register(<span class="string">"template"</span>, healthCheck);
    environment.jersey().register(resource);
}
</code></pre><h3 id="Building_JARs">Building JARs</h3><p>pom文件&lt;build&gt;&lt;plugins&gt;中添加：</p>
<pre><code><span class="variable">&lt;plugin&gt;</span>
    <span class="variable">&lt;groupId&gt;</span>org.apache.maven.plugins<span class="variable">&lt;/groupId&gt;</span>
    <span class="variable">&lt;artifactId&gt;</span>maven-jar-plugin<span class="variable">&lt;/artifactId&gt;</span>
    <span class="variable">&lt;version&gt;</span>2.4<span class="variable">&lt;/version&gt;</span>
    <span class="variable">&lt;configuration&gt;</span>
        <span class="variable">&lt;archive&gt;</span>
            <span class="variable">&lt;manifest&gt;</span>
                <span class="variable">&lt;addDefaultImplementationEntries&gt;</span>true<span class="variable">&lt;/addDefaultImplementationEntries&gt;</span>
            <span class="variable">&lt;/manifest&gt;</span>
        <span class="variable">&lt;/archive&gt;</span>
    <span class="variable">&lt;/configuration&gt;</span>
<span class="variable">&lt;/plugin&gt;</span>
<span class="variable">&lt;plugin&gt;</span>
    <span class="variable">&lt;groupId&gt;</span>org.apache.maven.plugins<span class="variable">&lt;/groupId&gt;</span>
    <span class="variable">&lt;artifactId&gt;</span>maven-shade-plugin<span class="variable">&lt;/artifactId&gt;</span>
    <span class="variable">&lt;version&gt;</span>1.6<span class="variable">&lt;/version&gt;</span>
    <span class="variable">&lt;configuration&gt;</span>
        <span class="variable">&lt;createDependencyReducedPom&gt;</span>true<span class="variable">&lt;/createDependencyReducedPom&gt;</span>
        <span class="variable">&lt;filters&gt;</span>
            <span class="variable">&lt;filter&gt;</span>
                <span class="variable">&lt;artifact&gt;</span><span class="keyword">*</span>:<span class="keyword">*</span><span class="variable">&lt;/artifact&gt;</span>
                <span class="variable">&lt;excludes&gt;</span>
                    <span class="variable">&lt;exclude&gt;</span>META-INF/<span class="keyword">*</span>.SF<span class="variable">&lt;/exclude&gt;</span>
                    <span class="variable">&lt;exclude&gt;</span>META-INF/<span class="keyword">*</span>.DSA<span class="variable">&lt;/exclude&gt;</span>
                    <span class="variable">&lt;exclude&gt;</span>META-INF/<span class="keyword">*</span>.RSA<span class="variable">&lt;/exclude&gt;</span>
                <span class="variable">&lt;/excludes&gt;</span>
            <span class="variable">&lt;/filter&gt;</span>
        <span class="variable">&lt;/filters&gt;</span>
    <span class="variable">&lt;/configuration&gt;</span>
    <span class="variable">&lt;executions&gt;</span>
        <span class="variable">&lt;execution&gt;</span>
            <span class="variable">&lt;phase&gt;</span>package<span class="variable">&lt;/phase&gt;</span>
            <span class="variable">&lt;goals&gt;</span>
                <span class="variable">&lt;goal&gt;</span>shade<span class="variable">&lt;/goal&gt;</span>
            <span class="variable">&lt;/goals&gt;</span>
            <span class="variable">&lt;configuration&gt;</span>
                <span class="variable">&lt;transformers&gt;</span>
                    <span class="variable">&lt;transformer implementation="org.apache.maven.plugins.shade.resource.ServicesResourceTransformer"/&gt;</span>
                    <span class="variable">&lt;transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"&gt;</span>
                        <span class="variable">&lt;mainClass&gt;</span>com.example.helloworld.HelloWorldApplication<span class="variable">&lt;/mainClass&gt;</span>
                    <span class="variable">&lt;/transformer&gt;</span>
                <span class="variable">&lt;/transformers&gt;</span>
            <span class="variable">&lt;/configuration&gt;</span>
        <span class="variable">&lt;/execution&gt;</span>
    <span class="variable">&lt;/executions&gt;</span>
<span class="variable">&lt;/plugin&gt;</span>
</code></pre><h3 id="Running_Application">Running Application</h3><pre><code>java -jar target/hello-world-<span class="number">0.0</span><span class="number">.1</span>-SNAPSHOT.jar server hello-world.yml
</code></pre><h2 id="参考">参考</h2><ol>
<li><a href="https://dropwizard.github.io/dropwizard/getting-started.html" target="_blank" rel="external">Dropwizard- Getting Started</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>Dropwizard 是一个开源的Java框架，用于开发OPS友好、高性能的基于REST的后端。它是由Yammer开发的，来驱动基于JVM的后端。目前公司的Rest服务都是基于这个开发的。<br>]]>
    
    </summary>
    
      <category term="Dropwizard" scheme="http://xfhnever.com/tags/Dropwizard/"/>
    
      <category term="Framework" scheme="http://xfhnever.com/tags/Framework/"/>
    
      <category term="Jersey" scheme="http://xfhnever.com/tags/Jersey/"/>
    
      <category term="REST" scheme="http://xfhnever.com/tags/REST/"/>
    
      <category term="ttpod" scheme="http://xfhnever.com/tags/ttpod/"/>
    
      <category term="Framework" scheme="http://xfhnever.com/categories/Framework/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[POI(一)-介绍]]></title>
    <link href="http://xfhnever.com/2015/03/28/poi-intro/"/>
    <id>http://xfhnever.com/2015/03/28/poi-intro/</id>
    <published>2015-03-28T07:51:03.000Z</published>
    <updated>2015-10-01T15:20:08.000Z</updated>
    <content type="html"><![CDATA[<p>最近需要在Java程序中读取Excel，于是开始接触POI。</p>
<p>Apache POI是Apache软件基金会的开放源码函式库，POI提供API给Java程式对Microsoft Office格式档案读和写的功能。<br><a id="more"></a></p>
<h2 id="POI结构">POI结构</h2><ol>
<li>HSSF － 提供读写Microsoft Excel XLS格式档案的功能。</li>
<li>XSSF － 提供读写Microsoft Excel OOXML XLSX格式档案的功能。</li>
<li>HWPF － 提供读写Microsoft Word DOC格式档案的功能。</li>
<li>HSLF － 提供读写Microsoft PowerPoint格式档案的功能。</li>
<li>HDGF － 提供读Microsoft Visio格式档案的功能。</li>
<li>HPBF － 提供读Microsoft Publisher格式档案的功能。</li>
<li>HSMF － 提供读Microsoft Outlook格式档案的功能。</li>
</ol>
<p>HSSF是指Excel2007年以前的(.xls),XSSF是指2007年版本以上的(.xlsx).</p>
<h2 id="实例">实例</h2><pre><code><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt;  getIds(String filePath) <span class="keyword">throws</span> IOException {
    ArrayList&lt;Integer&gt; ids = <span class="keyword">new</span> ArrayList&lt;&gt;();
    <span class="keyword">if</span> (filePath == <span class="keyword">null</span>)
        <span class="keyword">return</span> ids;
    InputStream is = <span class="keyword">new</span> FileInputStream(filePath);
    HSSFWorkbook hssfWorkbook = <span class="keyword">new</span> HSSFWorkbook(is);

    HSSFSheet hssfSheet = hssfWorkbook.getSheetAt(<span class="number">0</span>);
    <span class="keyword">if</span> (hssfSheet == <span class="keyword">null</span>)
        <span class="keyword">return</span> ids;

    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;hssfSheet.getLastRowNum(); i++) {
        HSSFRow hssfRow = hssfSheet.getRow(i);
        <span class="keyword">if</span> (hssfRow == <span class="keyword">null</span>)
            <span class="keyword">continue</span>;
        ids.add(getValue(hssfRow.getCell(<span class="number">0</span>)));
    }
    <span class="keyword">return</span> ids;
}

<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> writeToXLS(List&lt;SongDto&gt; songDtos, String filePath) <span class="keyword">throws</span> IOException {
    <span class="keyword">if</span> (songDtos == <span class="keyword">null</span> || filePath == <span class="keyword">null</span>)
        <span class="keyword">return</span>;

    HSSFWorkbook hssfWorkbook = <span class="keyword">new</span> HSSFWorkbook();
    HSSFSheet sheet = hssfWorkbook.createSheet(<span class="string">"song"</span>);
    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;songDtos.<span class="keyword">size</span>(); i++) {
        HSSFRow row = sheet.createRow(i);
        SongDto songDto = songDtos.get(i);
        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++) {
            HSSFCell song_id = row.createCell(<span class="number">0</span>);
            HSSFCell song_name = row.createCell(<span class="number">1</span>);
            HSSFCell singer_name = row.createCell(<span class="number">2</span>);
            HSSFCell status = row.createCell(<span class="number">3</span>);
            song_id.setCellValue(songDto.getId());
            song_name.setCellValue(songDto.getName());
            singer_name.setCellValue(songDto.getSingerName());
            status.setCellValue(songDto.getStatus());
        }
    }

    <span class="keyword">File</span> <span class="keyword">file</span> = <span class="keyword">new</span> <span class="keyword">File</span>(filePath);
    OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="keyword">file</span>);
    hssfWorkbook.<span class="keyword">write</span>(os);
    os.close();
}

<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> getValue(HSSFCell cell) {
    <span class="keyword">if</span> (cell.getCellType() == Cell.CELL_TYPE_NUMERIC)
        <span class="keyword">return</span> <span class="keyword">Double</span>.valueOf(cell.getNumericCellValue()).intValue();
    <span class="keyword">else</span> <span class="keyword">if</span> (cell.getCellType() == Cell.CELL_TYPE_STRING) 
        <span class="keyword">return</span> Integer.parseInt(cell.getStringCellValue());
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>上面的实例是：读取Excel第一列的数据到List中，将List中数据写入到Excel。</p>
<h2 id="参考">参考</h2><ol>
<li><a href="http://poi.apache.org/index.html" target="_blank" rel="external">Apache POI - the Java API for Microsoft Documents</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近需要在Java程序中读取Excel，于是开始接触POI。</p>
<p>Apache POI是Apache软件基金会的开放源码函式库，POI提供API给Java程式对Microsoft Office格式档案读和写的功能。<br>]]>
    
    </summary>
    
      <category term="Excel" scheme="http://xfhnever.com/tags/Excel/"/>
    
      <category term="POI" scheme="http://xfhnever.com/tags/POI/"/>
    
      <category term="Tools" scheme="http://xfhnever.com/tags/Tools/"/>
    
      <category term="Tools" scheme="http://xfhnever.com/categories/Tools/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mongodb(十一)- Array Operators]]></title>
    <link href="http://xfhnever.com/2015/03/23/mongodb-operatearrayelement/"/>
    <id>http://xfhnever.com/2015/03/23/mongodb-operatearrayelement/</id>
    <published>2015-03-23T12:22:34.000Z</published>
    <updated>2015-10-28T14:13:00.000Z</updated>
    <content type="html"><![CDATA[<p>MongoDB中的Document是通过嵌套来描述数据之间的关系。对于嵌套了数组的Document来说，如何操作被嵌套的数组是本章我们将要介绍的内容。<br><a id="more"></a></p>
<p>首先我们给出一个Document－songlist：</p>
<pre><code>{
  "<span class="attribute">_id</span>" : <span class="value"><span class="number">10</span></span>,
  "<span class="attribute">createdTime</span>" : <span class="value"><span class="number">1363246285</span></span>,
  "<span class="attribute">lastUpdated</span>" : <span class="value"><span class="number">1371398400</span></span>,
  "<span class="attribute">songs</span>" : <span class="value">[{
      "<span class="attribute">song_id</span>" : <span class="value"><span class="number">6086104</span></span>,
      "<span class="attribute">order</span>" : <span class="value"><span class="number">1</span>
    </span>}, {
      "<span class="attribute">song_id</span>" : <span class="value"><span class="number">2049114</span></span>,
      "<span class="attribute">order</span>" : <span class="value"><span class="number">2</span>
    </span>}, {
      "<span class="attribute">song_id</span>" : <span class="value"><span class="number">1030287</span></span>,
      "<span class="attribute">order</span>" : <span class="value"><span class="number">3</span>
    </span>}, {
      "<span class="attribute">song_id</span>" : <span class="value"><span class="number">4306167</span></span>,
      "<span class="attribute">order</span>" : <span class="value"><span class="number">4</span>
    </span>}, {
      "<span class="attribute">song_id</span>" : <span class="value"><span class="number">2089947</span></span>,
      "<span class="attribute">order</span>" : <span class="value"><span class="number">5</span>
    </span>}, {
      "<span class="attribute">song_id</span>" : <span class="value"><span class="number">4487220</span></span>,
      "<span class="attribute">order</span>" : <span class="value"><span class="number">6</span>
    </span>}, {
      "<span class="attribute">song_id</span>" : <span class="value"><span class="number">989231</span></span>,
      "<span class="attribute">order</span>" : <span class="value"><span class="number">7</span>
    </span>}, {
      "<span class="attribute">song_id</span>" : <span class="value"><span class="number">6079061</span></span>,
      "<span class="attribute">order</span>" : <span class="value"><span class="number">8</span>
    </span>}, {
      "<span class="attribute">song_id</span>" : <span class="value"><span class="number">2918203</span></span>,
      "<span class="attribute">order</span>" : <span class="value"><span class="number">9</span>
    </span>}, {
      "<span class="attribute">song_id</span>" : <span class="value"><span class="number">6079120</span></span>,
      "<span class="attribute">order</span>" : <span class="value"><span class="number">10</span>
    </span>}]</span>,
  "<span class="attribute">online_time</span>" : <span class="value"><span class="number">1371398400</span>
</span>}
</code></pre><p>如果我们需要往songs中添加一些歌或者删除一些歌，一种思路是直接取出整个文档，然后使用修改后的songs替换掉本来文档中的songs，然后再update整个文档。上面这种思路我们需要访问两次数据库，同时还需要手工遍历数组。更好的选择是直接操作文档中的数组。</p>
<h2 id="添加">添加</h2><h3 id="pushAll">pushAll</h3><p>将特定的值列表添加到数组中，格式如下：</p>
<pre><code>{ <span class="variable">$pushAll</span>: { &lt;field&gt;: [ &lt;value1&gt;, &lt;value2&gt;, ... ] } }
</code></pre><h3 id="push">push</h3><p>将一个特定的值添加到数组中，格式如下：</p>
<pre><code>{ <span class="variable">$push</span>: { &lt;field1&gt;: &lt;value1&gt;, ... }
</code></pre><p>2.4版本之后，push加上each代替了本来的pushAll。</p>
<pre><code>db.songlist.<span class="keyword">update</span>(
   { _id: <span class="number">10</span> },
   {
     <span class="variable">$push</span>: {
       songs: {
          <span class="variable">$each</span>: [ { song_id: <span class="number">5</span>, order: <span class="number">8</span> }, { song_id: <span class="number">6</span>, order: <span class="number">9</span> }, { song_id: <span class="number">7</span>, order: <span class="number">6</span> } ],
          <span class="variable">$sort</span>: { order: -<span class="number">1</span> },
          <span class="variable">$slice</span>: <span class="number">3</span>
       }
     }
   }
)
</code></pre><p>其中：</p>
<ol>
<li>the <strong>$each</strong> modifier to append to the array 2 new elements,</li>
<li>the <strong>$sort</strong> modifier to order the elements by ascending (1) score</li>
<li>the <strong>$slice</strong> modifier to keep the last 3 elements of the ordered array.</li>
</ol>
<h3 id="addToSet">addToSet</h3><p>The $addToSet operator adds a value to an array only if the value is not already in the array. If the value is in the array, $addToSet does not modify the array</p>
<pre><code>{ <span class="variable">$addToSet</span>: { &lt;field1&gt;: &lt;value1&gt;, ... } }
</code></pre><h2 id="删除">删除</h2><h3 id="pullAll">pullAll</h3><p>删除数组中存在于给定列表中元素，格式如下：</p>
<pre><code>{ <span class="variable">$pullAll</span>: { &lt;field1&gt;: [ &lt;value1&gt;, &lt;value2&gt; ... ], ... } }
</code></pre><h3 id="pull">pull</h3><p>pull操作符可以定义查询语句，根据条件进行删除，格式如下：</p>
<pre><code>{ <span class="variable">$pull</span>: { &lt;field1&gt;: &lt;value|query&gt;, ... } }
</code></pre><p>实例：</p>
<pre><code>db.songlist.<span class="keyword">update</span>(
  { },
  { <span class="variable">$pull</span>: { songs: { song_id: <span class="number">8</span> , order: <span class="number">10</span> } } },
  { multi: true }
)
</code></pre><h3 id="pop">pop</h3><p>The $pop operator removes the first or last element of an array. Pass $pop a value of -1 to remove the first element of an array and 1 to remove the last element in an array.</p>
<pre><code>{ <span class="variable">$pop</span>: { &lt;field&gt;: &lt;-<span class="number">1</span> | <span class="number">1</span>&gt;, ... } }
</code></pre><h2 id="提取数组部分信息">提取数组部分信息</h2><p>根据上面的介绍，我们发现可以使用slice限定数组元素长度</p>
<pre><code>{
  <span class="variable">$push</span>: {
     &lt;field&gt;: {
       <span class="variable">$each</span>: [ &lt;value1&gt;, &lt;value2&gt;, ... ],
       <span class="variable">$slice</span>: &lt;num&gt;
     }
  }
}
</code></pre><p>其中num可以是：</p>
<ol>
<li><strong>Zero</strong>：    To update the array <field> to an empty array.</field></li>
<li><strong>Negative</strong>：    To update the array <field> to contain only the last <num> elements.</num></field></li>
<li><strong>Positive</strong>：    To update the array <field> contain only the first <num> elements.</num></field></li>
</ol>
<h2 id="参考">参考</h2><p><a href="http://docs.mongodb.org/manual/reference/operator/update/addToSet/" target="_blank" rel="external">官方文档</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>MongoDB中的Document是通过嵌套来描述数据之间的关系。对于嵌套了数组的Document来说，如何操作被嵌套的数组是本章我们将要介绍的内容。<br>]]>
    
    </summary>
    
      <category term="DB" scheme="http://xfhnever.com/tags/DB/"/>
    
      <category term="MongoDB" scheme="http://xfhnever.com/tags/MongoDB/"/>
    
      <category term="DB" scheme="http://xfhnever.com/categories/DB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[zookeeper（二）- 原理]]></title>
    <link href="http://xfhnever.com/2015/03/22/zookeeper-principle/"/>
    <id>http://xfhnever.com/2015/03/22/zookeeper-principle/</id>
    <published>2015-03-22T05:47:39.000Z</published>
    <updated>2015-10-01T15:23:32.000Z</updated>
    <content type="html"><![CDATA[<p>之前的blog简单介绍了zookeeper的特性，安装配置和适用范围，本章我们将进一步介绍zookeeper的基本原理。<br><a id="more"></a></p>
<h2 id="重要概念">重要概念</h2><h3 id="数据模型">数据模型</h3><img src="/images/post/zookeeper2-1.jpg">
<p>如上图所示，ZooKeeper数据模型的结构与Unix文件系统很类似，整体上可以看作是一棵树，每个节点称做一个ZNode。每个ZNode都可以通过其路径唯一标识，比如上图中第三层的第一个ZNode, 它的路径是/app1/c1。在每个ZNode上可存储少量数据(默认是1M, 可以通过配置修改, 通常不建议在ZNode上存储大量的数据)，这个特性非常有用，在后面的典型应用场景中会介绍到。另外，每个ZNode上还存储了其Acl信息，这里需要注意，虽说ZNode的树形结构跟Unix文件系统很类似，但是其Acl与Unix文件系统是完全不同的，每个ZNode的Acl的独立的，子结点不会继承父结点的。</p>
<h3 id="ZNode">ZNode</h3><p>前文已介绍了ZNode, ZNode根据其本身的特性，可以分为下面两类：</p>
<ol>
<li>Regular ZNode: 常规型ZNode, 用户需要显式的创建、删除</li>
<li>Ephemeral ZNode: 临时型ZNode, 用户创建它之后，可以显式的删除，也可以在创建它的Session结束后，由ZooKeeper Server自动删除</li>
</ol>
<p>ZNode还有一个Sequential的特性，如果创建的时候指定的话，该ZNode的名字后面会自动Append一个不断增加的SequenceNo。</p>
<h3 id="Session">Session</h3><p>Client与ZooKeeper之间的通信，需要创建一个Session，这个Session会有一个超时时间。因为ZooKeeper集群会把Client的Session信息持久化，所以在Session没超时之前，Client与ZooKeeper Server的连接可以在各个ZooKeeper Server之间透明地移动。</p>
<p>在实际的应用中，如果Client与Server之间的通信足够频繁，Session的维护就不需要其它额外的消息了。否则，ZooKeeper Client会每t/3 ms发一次心跳给Server，如果Client 2t/3 ms没收到来自Server的心跳回应，就会换到一个新的ZooKeeper Server上。这里t是用户配置的Session的超时时间。</p>
<h3 id="Watcher">Watcher</h3><p>ZooKeeper支持一种Watch操作，Client可以在某个ZNode上设置一个Watcher，来Watch该ZNode上的变化。如果该ZNode上有相应的变化，就会触发这个Watcher，把相应的事件通知给设置Watcher的Client。需要注意的是，ZooKeeper中的Watcher是一次性的，即触发一次就会被取消，如果想继续Watch的话，需要客户端重新设置Watcher。这个跟epoll里的oneshot模式有点类似。</p>
<h3 id="角色">角色</h3><p>Zookeeper中的角色主要有以下三类，如下表所示：</p>
<img src="/images/post/zookeeper2-2.jpg">
<p>系统模型如图所示：</p>
<img src="/images/post/zookeeper2-3.jpg">
<h2 id="工作原理">工作原理</h2><p>Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。</p>
<p>为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。</p>
<p>每个Server在工作过程中有三种状态：</p>
<ol>
<li>LOOKING：当前Server不知道leader是谁，正在搜寻</li>
<li>LEADING：当前Server即为选举出来的leader</li>
<li>FOLLOWING：leader已经选举出来，当前Server与之同步</li>
</ol>
<h3 id="选主流程">选主流程</h3><p>当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic paxos实现的，另外一种是基于fast paxos算法实现的。系统默认的选举算法为fast paxos。先介绍basic paxos流程：</p>
<ol>
<li>选举线程由当前Server发起选举的线程担任，其主要功能是对投票结果进行统计，并选出推荐的Server；</li>
<li>选举线程首先向所有Server发起一次询问(包括自己)；</li>
<li>选举线程收到回复后，验证是否是自己发起的询问(验证zxid是否一致)，然后获取对方的id(myid)，并存储到当前询问对象列表中，最后获取对方提议的leader相关信息(id,zxid)，并将这些信息存储到当次选举的投票记录表中；</li>
<li>收到所有Server回复以后，就计算出zxid最大的那个Server，并将这个Server相关信息设置成下一次要投票的Server；</li>
<li>线程将当前zxid最大的Server设置为当前Server要推荐的Leader，如果此时获胜的Server获得n/2 + 1的Server票数， 设置当前推荐的leader为获胜的Server，将根据获胜的Server相关信息设置自己的状态，否则，继续这个过程，直到leader被选举出来。</li>
</ol>
<p>每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。选主的具体流程图如下所示：</p>
<img src="/images/post/zookeeper2-4.jpg">
<p>fast paxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。其流程图如下所示：</p>
<img src="/images/post/zookeeper2-5.jpg">
<h3 id="同步流程">同步流程</h3><p>选完leader以后，zk就进入状态同步过程。</p>
<ol>
<li>leader等待server连接；</li>
<li>Follower连接leader，将最大的zxid发送给leader；</li>
<li>Leader根据follower的zxid确定同步点；</li>
<li>完成同步后通知follower 已经成为uptodate状态；</li>
<li>Follower收到uptodate消息后，又可以重新接受client的请求进行服务了。</li>
</ol>
<img src="/images/post/zookeeper2-6.jpg">
<h3 id="工作流程">工作流程</h3><h3 id="Leader工作流程">Leader工作流程</h3><p>Leader主要有三个功能:</p>
<ol>
<li>恢复数据；</li>
<li>维持与Learner的心跳，接收Learner请求并判断Learner的请求消息类型；</li>
<li>Learner的消息类型主要有PING消息、REQUEST消息、ACK消息、REVALIDATE消息，根据不同的消息类型，进行不同的处理。</li>
</ol>
<p>PING消息是指Learner的心跳信息；REQUEST消息是Follower发送的提议信息，包括写请求及同步请求；ACK消息是Follower的对提议的回复，超过半数的Follower通过，则commit该提议；REVALIDATE消息是用来延长SESSION有效时间。</p>
<img src="/images/post/zookeeper2-7.jpg">
<h3 id="Follower工作流程">Follower工作流程</h3><p>Follower主要有四个功能：</p>
<ol>
<li>向Leader发送请求（PING消息、REQUEST消息、ACK消息、REVALIDATE消息）；</li>
<li>接收Leader消息并进行处理；</li>
<li>接收Client的请求，如果为写请求，发送给Leader进行投票</li>
<li>返回Client结果。</li>
</ol>
<p>Follower的消息循环处理如下几种来自Leader的消息：</p>
<ol>
<li>PING消息： 心跳消息；</li>
<li>PROPOSAL消息：Leader发起的提案，要求Follower投票；</li>
<li>COMMIT消息：服务器端最新一次提案的信息；</li>
<li>UPTODATE消息：表明同步完成；</li>
<li>REVALIDATE消息：根据Leader的REVALIDATE结果，关闭待revalidate的session还是允许其接受消息；</li>
<li>SYNC消息：返回SYNC结果到客户端，这个消息最初由客户端发起，用来强制得到最新的更新。</li>
</ol>
<p>Follower的工作流程简图如下所示，在实际实现中，Follower是通过5个线程来实现功能的。</p>
<img src="/images/post/zookeeper2-8.jpg">
<p>对于observer的流程不再叙述，observer流程和Follower的唯一不同的地方就是observer不会参加leader发起的投票。</p>
<h2 id="参考">参考</h2><ol>
<li><a href="http://cailin.iteye.com/blog/2014486" target="_blank" rel="external">zookeeper原理（转）</a></li>
<li><a href="http://www.wuzesheng.com/?p=2609" target="_blank" rel="external">ZooKeeper原理及使用</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前的blog简单介绍了zookeeper的特性，安装配置和适用范围，本章我们将进一步介绍zookeeper的基本原理。<br>]]>
    
    </summary>
    
      <category term="Framework" scheme="http://xfhnever.com/tags/Framework/"/>
    
      <category term="Zookeeper" scheme="http://xfhnever.com/tags/Zookeeper/"/>
    
      <category term="ttpod" scheme="http://xfhnever.com/tags/ttpod/"/>
    
      <category term="Framework" scheme="http://xfhnever.com/categories/Framework/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[zookeeper（一）- 介绍]]></title>
    <link href="http://xfhnever.com/2015/03/12/zookeeper-intro/"/>
    <id>http://xfhnever.com/2015/03/12/zookeeper-intro/</id>
    <published>2015-03-12T02:40:59.000Z</published>
    <updated>2015-10-01T15:24:53.000Z</updated>
    <content type="html"><![CDATA[<p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、名字服务、分布式同步、组服务等。<br><a id="more"></a><br>ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。</p>
<p>ZooKeeper包含一个简单的原语集，提供Java和C的接口。</p>
<h2 id="特点">特点</h2><ol>
<li>最终一致性：client不论连接到哪个Server，展示给它都是同一个视图，这是zookeeper最重要的性能。</li>
<li>可靠性：具有简单、健壮、良好的性能，如果消息m被到一台服务器接受，那么它将被所有的服务器接受。</li>
<li>实时性：Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。但由于网络延时等原因，Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。</li>
<li>等待无关（wait-free）：慢的或者失效的client不得干预快速的client的请求，使得每个client都能有效的等待。</li>
<li>原子性：更新只能成功或者失败，没有中间状态。</li>
<li>顺序性：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。</li>
</ol>
<h2 id="安装配置">安装配置</h2><p>Zookeeper的安装和配置十分简单, 既可以配置成单机模式, 也可以配置成集群模式. </p>
<h3 id="单机模式">单机模式</h3><p>单机安装非常简单，下载之后解压就可以，然后linux或者mac系统下可以启动脚本zkServer.sh。</p>
<p>不过在执行启动脚本之前，还有几个基本的配置项需要配置一下，Zookeeper 的配置文件在 conf 目录下，这个目录下有 zoo_sample.cfg 和 log4j.properties，你需要做的就是将 zoo_sample.cfg 改名为 zoo.cfg，因为 Zookeeper 在启动时会找这个文件作为默认配置文件。下面详细介绍一下，这个配置文件中各个配置项的意义。</p>
<pre><code>tickTime=<span class="number">2000</span> 
dataDir=<span class="constant">D</span><span class="symbol">:/devtools/zookeeper-</span><span class="number">3.2</span>.<span class="number">2</span>/build 
clientPort=<span class="number">2181</span>
</code></pre><p>下面详细介绍一下，这个配置文件中各个配置项的意义。</p>
<ol>
<li>tickTime：这个时间是作为 Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。</li>
<li>dataDir：顾名思义就是 Zookeeper 保存数据的目录，默认情况下，Zookeeper 将写数据的日志文件也保存在这个目录里。</li>
<li>clientPort：这个端口就是客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。</li>
</ol>
<h3 id="集群模式">集群模式</h3><p>Zookeeper 不仅可以单机提供服务，同时也支持多机组成集群来提供服务。实际上 Zookeeper 还支持另外一种伪集群的方式，也就是可以在一台物理机上运行多个 Zookeeper 实例，下面将介绍集群模式的安装和配置。</p>
<p>Zookeeper 的集群模式的安装和配置也不是很复杂，所要做的就是增加几个配置项。集群模式除了上面的三个配置项还要增加下面几个配置项：</p>
<pre><code>initLimit=<span class="number">5</span> 
syncLimit=<span class="number">2</span> 
server<span class="number">.1</span>=<span class="number">192.168</span><span class="number">.211</span><span class="number">.1</span>:<span class="number">2888</span>:<span class="number">3888</span> 
server<span class="number">.2</span>=<span class="number">192.168</span><span class="number">.211</span><span class="number">.2</span>:<span class="number">2888</span>:<span class="number">3888</span>
</code></pre><p>各个配置项的意义：</p>
<ol>
<li>initLimit：这个配置项是用来配置 Zookeeper 接受客户端（这里所说的客户端不是用户连接 Zookeeper 服务器的客户端，而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过 10 个心跳的时间（也就是 tickTime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是 5*2000=10 秒</li>
<li>syncLimit：这个配置项标识 Leader 与 Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 2*2000=4 秒</li>
<li>server.A=B：C：D：其中 A 是一个数字，表示这个是第几号服务器；B 是这个服务器的 ip 地址；C 表示的是这个服务器与集群中的 Leader 服务器交换信息的端口；D 表示的是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。如果是伪集群的配置方式，由于 B 都是一样，所以不同的 Zookeeper 实例通信端口号不能一样，所以要给它们分配不同的端口号。</li>
</ol>
<p>除了修改 zoo.cfg 配置文件，集群模式下还要配置一个文件 myid，这个文件在 dataDir 目录下，这个文件里面就有一个数据就是 A 的值，Zookeeper 启动时会读取这个文件，拿到里面的数据与 zoo.cfg 里面的配置信息比较从而判断到底是那个 server。</p>
<h2 id="应用场景">应用场景</h2><h3 id="名字服务(NameService)">名字服务(NameService)</h3><p>分布式应用中，通常需要有一套完整的命名规则，既能够产生唯一的名称又便于人识别和记住，通常情况下用树形的名称结构是一个理想的选择，树形的名称结构是一个有层次的目录结构，既对人友好又不会重复。说到这里你可能想到了 JNDI，没错 Zookeeper 的 Name Service 与 JNDI 能够完成的功能是差不多的，它们都是将有层次的目录结构关联到一定资源上，但是 Zookeeper 的 Name Service 更加是广泛意义上的关联，也许你并不需要将名称关联到特定资源上，你可能只需要一个不会重复名称，就像数据库中产生一个唯一的数字主键一样。</p>
<p>Name Service 已经是 Zookeeper 内置的功能，你只要调用 Zookeeper 的 API 就能实现。如调用 create 接口就可以很容易创建一个目录节点。</p>
<h3 id="配置管理(Configuration_Management)">配置管理(Configuration Management)</h3><p>在分布式系统中，常会遇到这样的场景: 某个Job的很多个实例在运行，它们在运行时大多数配置项是相同的，如果想要统一改某个配置，一个个实例去改，是比较低效，也是比较容易出错的方式。通过ZooKeeper可以很好的解决这样的问题，下面的基本的步骤：</p>
<ol>
<li>将公共的配置内容放到ZooKeeper中某个ZNode上，比如/service/common-conf</li>
<li>所有的实例在启动时都会传入ZooKeeper集群的入口地址，并且在运行过程中Watch /service/common-conf这个ZNode</li>
<li>如果集群管理员修改了了common-conf，所有的实例都会被通知到，根据收到的通知更新自己的配置，并继续Watch /service/common-conf</li>
</ol>
<h3 id="集群管理（Group_Membership）">集群管理（Group Membership）</h3><p>Zookeeper 能够很容易的实现集群管理的功能，如有多台 Server 组成一个服务集群，那么必须要一个“总管”知道当前集群中每台机器的服务状态，一旦有机器不能提供服务，集群中其它集群必须知道，从而做出调整重新分配服务策略。同样当增加集群的服务能力时，就会增加一台或多台 Server，同样也必须让“总管”知道。</p>
<p>Zookeeper 不仅能够帮你维护当前的集群中机器的服务状态，而且能够帮你选出一个“总管”，让这个总管来管理集群，这就是 Zookeeper 的另一个功能 Leader Election。</p>
<p>它们的实现方式都是在 Zookeeper 上创建一个 EPHEMERAL 类型的目录节点，然后每个 Server 在它们创建目录节点的父目录节点上调用 getChildren(String path, boolean watch) 方法并设置 watch 为 true，由于是 EPHEMERAL 目录节点，当创建它的 Server 死去，这个目录节点也随之被删除，所以 Children 将会变化，这时 getChildren上的 Watch 将会被调用，所以其它 Server 就知道已经有某台 Server 死去了。新增 Server 也是同样的原理。</p>
<p>Zookeeper 如何实现 Leader Election，也就是选出一个 Master Server。和前面的一样每台 Server 创建一个 EPHEMERAL 目录节点，不同的是它还是一个 SEQUENTIAL 目录节点，所以它是个 EPHEMERAL_SEQUENTIAL 目录节点。之所以它是 EPHEMERAL_SEQUENTIAL 目录节点，是因为我们可以给每台 Server 编号，我们可以选择当前是最小编号的 Server 为 Master，假如这个最小编号的 Server 死去，由于是 EPHEMERAL 节点，死去的 Server 对应的节点也被删除，所以当前的节点列表中又出现一个最小编号的节点，我们就选择这个节点为当前 Master。这样就实现了动态选择 Master，避免了传统意义上单 Master 容易出现单点故障的问题。</p>
<img src="/images/post/zookeeper1-1.png">
<h3 id="简单互斥锁(Simple_Lock)">简单互斥锁(Simple Lock)</h3><p>在传统的应用程序中，线程、进程的同步，都可以通过操作系统提供的机制来完成。但是在分布式系统中，多个进程之间的同步，操作系统层面就无能为力了。这时候就需要像ZooKeeper这样的分布式的协调(Coordination)服务来协助完成同步，下面是用ZooKeeper实现简单的互斥锁的步骤，这个可以和线程间同步的mutex做类比来理解：</p>
<ol>
<li>多个进程尝试去在指定的目录下去创建一个临时性(Ephemeral)结点 /locks/my_lock</li>
<li>ZooKeeper能保证，只会有一个进程成功创建该结点，创建结点成功的进程就是抢到锁的进程，假设该进程为A</li>
<li>其它进程都对/locks/my_lock进行Watch</li>
<li>当A进程不再需要锁，可以显式删除/locks/my_lock释放锁；或者是A进程宕机后Session超时，ZooKeeper系统自动删除/locks/my_lock结点释放锁。此时，其它进程就会收到ZooKeeper的通知，并尝试去创建/locks/my_lock抢锁，如此循环反复</li>
</ol>
<h3 id="互斥锁(Simple_Lock_without_Herd_Effect)">互斥锁(Simple Lock without Herd Effect)</h3><p>上一例子中有一个问题，每次抢锁都会有大量的进程去竞争，会造成羊群效应(Herd Effect)，为了解决这个问题，我们可以通过下面的步骤来改进上述过程：</p>
<ol>
<li>每个进程都在ZooKeeper上创建一个临时的顺序结点(Ephemeral Sequential) /locks/lock_${seq}<br>${seq}最小的为当前的持锁者(${seq}是ZooKeeper生成的Sequenctial Number)</li>
<li>其它进程都对只watch比它次小的进程对应的结点，比如2 watch 1, 3 watch 2, 以此类推</li>
<li>当前持锁者释放锁后，比它次大的进程就会收到ZooKeeper的通知，它成为新的持锁者，如此循环反复</li>
</ol>
<p>这里需要补充一点，通常在分布式系统中用ZooKeeper来做Leader Election(选主)就是通过上面的机制来实现的，这里的持锁者就是当前的“主”。</p>
<h3 id="读写锁(Read/Write_Lock)">读写锁(Read/Write Lock)</h3><p>读写锁跟互斥锁相比不同的地方是，它分成了读和写两种模式，多个读可以并发执行，但写和读、写都互斥，不能同时执行行。利用ZooKeeper，在上面的基础上，稍做修改也可以实现传统的读写锁的语义，下面是基本的步骤:</p>
<ol>
<li>每个进程都在ZooKeeper上创建一个临时的顺序结点(Ephemeral Sequential) /locks/lock_${seq}</li>
<li>${seq}最小的一个或多个结点为当前的持锁者，多个是因为多个读可以并发</li>
<li>需要写锁的进程，Watch比它次小的进程对应的结点</li>
<li>需要读锁的进程，Watch比它小的最后一个写进程对应的结点</li>
<li>当前结点释放锁后，所有Watch该结点的进程都会被通知到，他们成为新的持锁者，如此循环反复</li>
</ol>
<h3 id="屏障(Barrier)">屏障(Barrier)</h3><p>在分布式系统中，屏障是这样一种语义: 客户端需要等待多个进程完成各自的任务，然后才能继续往前进行下一步。下用是用ZooKeeper来实现屏障的基本步骤：</p>
<ol>
<li>Client在ZooKeeper上创建屏障结点/barrier/my_barrier，并启动执行各个任务的进程</li>
<li>Client通过exist()来Watch /barrier/my_barrier结点</li>
<li>每个任务进程在完成任务后，去检查是否达到指定的条件，如果没达到就啥也不做，如果达到了就把/barrier/my_barrier结点删除</li>
<li>Client收到/barrier/my_barrier被删除的通知，屏障消失，继续下一步任务</li>
</ol>
<h3 id="双屏障(Double_Barrier)">双屏障(Double Barrier)</h3><p>双屏障是这样一种语义: 它可以用来同步一个任务的开始和结束，当有足够多的进程进入屏障后，才开始执行任务；当所有的进程都执行完各自的任务后，屏障才撤销。下面是用ZooKeeper来实现双屏障的基本步骤：</p>
<p>进入屏障：</p>
<ol>
<li>Client Watch /barrier/ready结点, 通过判断该结点是否存在来决定是否启动任务</li>
<li>每个任务进程进入屏障时创建一个临时结点/barrier/process/${process_id}，然后检查进入屏障的结点数是否达到指定的值，如果达到了指定的值，就创建一个/barrier/ready结点，否则继续等待</li>
<li>Client收到/barrier/ready创建的通知，就启动任务执行过程</li>
</ol>
<p>离开屏障：</p>
<ol>
<li>Client Watch /barrier/process，如果其没有子结点，就可以认为任务执行结束，可以离开屏障</li>
<li>每个任务进程执行任务结束后，都需要删除自己对应的结点/barrier/process/${process_id}</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、名字服务、分布式同步、组服务等。<br>]]>
    
    </summary>
    
      <category term="Framework" scheme="http://xfhnever.com/tags/Framework/"/>
    
      <category term="Zookeeper" scheme="http://xfhnever.com/tags/Zookeeper/"/>
    
      <category term="ttpod" scheme="http://xfhnever.com/tags/ttpod/"/>
    
      <category term="Framework" scheme="http://xfhnever.com/categories/Framework/"/>
    
  </entry>
  
</feed>
